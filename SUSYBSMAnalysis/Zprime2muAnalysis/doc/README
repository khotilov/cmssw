The Zprime2muAnalysis package
-----------------------------

Authors: Robert Cousins
         Jason Mumford
         Jordan Tucker
         Slava Valuev
         (UCLA)

Electron Extension Contributor: Jeremy Werner (Princeton)

Zprime2muAnalysis consists of several analysis modules intended for
studying high-mass resonances.

Zprime2muAnalysis:   fills vectors of leptons, constructs dileptons,
                     calculates invariant mass and other quantities. This is
                     the base class for the other modules, so its code is
                     called in each of them.

Zprime2muResolution: calculates resolutions (mass, phi, eta, etc.) of
                     the lepton fits at different levels of reconstruction
                     and plots them.

Zprime2muAsymmetry:  performs 6D unbinned maximum-likelihood fits to measure
                     the forward-backward asymmetry (A_{FB}) for Drell-Yan
                     and Z' events, for both generated and reconstructed
                     leptons (see CMS NOTE 2005/022).

Zprime2muMassReach:  performs unbinned maximum-likelihood fits to measure
                     signal and background contribution to the dilepton
                     spectrum and calculates the discovery potential for a
                     given integrated luminosity (see CMS NOTE 2006/062).

As mentioned above, Zprime2muAnalysis is not intended to be run
separately, except for debugging purposes. In this case it will dump
to the appropriate MessageLogger destination various messages
concerning the selection of leptons (either generated, or at various
levels of reconstruction) and the assembling of dileptons.

The .cfg files in the test/ subdirectory illustrate usage of these
modules; default parameters for each module are specified in the .cfi
and .cff files in the data/ subdirectory. As in the .cfg files, in
general these modules take as input EDM ROOT files with
fully-reconstructed (i.e. GEN-SIM-DIGI-L1-HLT-RECO all performed)
gamma*/Z0/Z'/G/G* --> l- l+ events (with l=e,mu). Some sample files
are available at /castor/cern.ch/user/t/tucker/CMSSW_1_6_7.

At the time this documentation was updated, the package has been
tested to work with version 1_6_11 of CMSSW. The tag V00-01-02 should
be used. We have abandoned our private BaseMuon/Muon/DiMuon classes in
favor of using directly the standard AnalysisTools classes
(reco::Candidate and all its derived classes, including those of the
PAT).

While much of the base class Zprime2muAnalysis along with its provided
interface for accessing the (di)lepton four-vectors and other data has
changed from V00-00-* series, the bulk of the logic in the derived
classes has remained the same, as has the physics. The rest of this
document is devoted to details of how the standard AnalysisTools
classes are used, how the data can be accessed by customers of the
base class, Zprime2muAnalysis, and how the three included analysis
modules, Resolution, Asymmetry, and MassReach, can be configured and
run.


Philosophy
----------

Inside the base class Zprime2muAnalysis, leptons are stored at
different levels of reconstruction ("rec levels"), of which there are
currently eight defined. These were originally for dealing with
different levels of muon reconstruction:

  - generated muons (GEN),
  - Level-1, Level-2, and Level-3 of the muon trigger system (L1, L2, L3),
  - globally-reconstructed muons (GMR),
  - tracker-only (TK),
  - tracker-plus-first-muon-station (FMS),
  - muons reconstructed "pickily" (PMR),
  - and "best" muons, chosen from the previous four options on a
    muon-by-muon basis using some track goodness-of-fit criteria (OPT).

TK, FMS, and PMR are designed to deal with showering TeV muons, for
which GMR is not the best choice for reconstruction.

When running in electron mode, these three rec levels are no longer
appropriate, and are simply left empty. OPT in electron mode is filled
with the output of the HEEPSelector written by D.L. Evans (which must be
checked out separately; see the example at the end of this document).

data/Zprime2muAnalysisCommon_cff.py organizes the various input
collections of leptons, first running any AnalysisTools modules to
produce, select, merge, or sort the collections needed for the various
levels of reconstruction of both muons and electrons. The VInputTags
muInputs and elInputs then match input collections to the right rec
levels (for electrons, skipping rec levels lTK through lPMR).

The input collections thus defined (whether CandidateCollections,
MuonCollections, or any other vector of objects deriving from
reco::Candidate) are accessed in the code using edm::View. In the
class, we store references to leptons as vectors of
reco::CandidateBaseRef objects:

  // excerpt from Zprime2muAnalysis.h
  typedef std::vector<reco::CandidateBaseRef> LeptonRefVector;
     ...
  LeptonRefVector allLeptons[MAX_LEVELS];
  LeptonRefVector bestLeptons;

one vector for each rec level. (CandidateBaseRefs were chosen over
CandidateRefs and vector<CandidateBaseRef> over CandidateBaseRefVector
for technical reasons documented in code comments.)

Matching between rec levels (especially to MC truth) and matching
closest photons is done in our own code in the module
LeptonAssociator, but stored in the same manner as the official
matching packages (i.e., in AssociationMaps). We chose to do this
instead of using the available AnalysisTools matching tools since,
with nine rec levels, it proved cumbersome to define matches between
leptons at each pair of rec levels and matches between each rec level
of leptons and photons in the configuration files. Many module
invocations to define the matching just between lepton rec levels
alone would be needed.

Now that we have moved to Python configuration files, running a loop
in the configuration file is just as easy as doing so in the code. We
still use LeptonAssociator, however, because it performs closest
matching slightly differently than TrivialDeltaRCandMatcher, and also
because it takes care of matching offline leptons to photons, and all
offline leptons to other offline leptons by "seed". By-seed matching
finds pairs of offline-reconstructed leptons that share the same seed
track in the muon system, which is useful when trying to pick the
"best" muon, since we need to know which muon in TK corresponds to
which in PMR, etc.

Dileptons are constructed as reco::CompositeCandidates, pruned of
overlap (if two dileptons share a lepton, preference is given to the
dilepton of higher invariant mass), and stored in
reco::CandidateCollections (one collection at each rec level). For
offline-reconstructed muons (GMR level and higher), an attempt is made
to recover energy loss from bremmed photons by adding in the
four-vectors of each of the leptons' closest photons, found in the
matching step above. The resulting "resonance" four-vector, however,
is not stored in the CompositeCandidate object, but is stored
separately in order to enable comparisons of the two in derived
analysis modules such as Zprime2muResolution. These resonance
four-vectors are stored simply: one vector of LorentzVectors for each
reconstruction level, in the same order as the dileptons.

Trigger information is also stored: for muons we look at the trigger
paths used by the 2007 high-mass dimuon analysis (the result of which
was presented in CMS AN 2007/038), and for electrons we look at the
trigger paths used by the HEEP group. For muons, the "official"
results are compared to a homemade implementation for trigger studies.

All of the above dumps helpful debugging information to the
MessageLogger, depending on the level of the verbosity flag; see its
discussion below.


Accessing this data in code
---------------------------

All of the methods which implement the above are declared private to
the base class Zprime2muAnalysis, but there are a number of methods
accessible from derived classes. The main documentation for these
exists in Zprime2muAnalysis.h, in the sections starting with
"Lepton/dilepton rec level utility functions". Examples of their use
are in the method dumpLepton() (which besides dumping debugging info,
was written for documentation purposes), and in the existing analysis
classes, Asymmetry, Resolution, and MassReach.


Configuring Zprime2muAnalysis
-----------------------------

There are quite a few flags and parameters of interest, which can be
set either editing data/*.cff or (preferably) in the config file using
the replace syntax. E.g. when running Zprime2muResolution, one might
put the following line in the cfg file:

  replace Zprime2muResolution.verbosity = 2

There are some flags common to all modules (since they are used by the
base class Zprime2muAnalysis):

  doingElectrons:    switch to using electron collections instead of muons
                     (see below section, "Electron Extension").
  constructGenDil:   whether to allow construction of generator-level
                     dileptons from generated leptons -- default behavior
                     is no, and to take the actual resonance from the PYTHIA
                     event record, but if there is none, as is the case in
                     some COMPHEP-generated samples, then the code will not
                     find any generated dilepton unless this is set.
  generatedOnly:     whether only to bother with generator-level information.
  reconstructedOnly: likewise, whether only to bother with reconstructed
                     information.
  useOtherMuonRecos: if set, look for other MuonCollections in the input file
                     named "muonsFMS", etc., which correspond to the other
                     available TeV muon reconstructors.
  usingAODOnly:      whether only to use objects that are available in the
                     AOD; this overrides generatedOnly, reconstructedOnly,
                     and useOtherMuonRecos with the values false, true, and
                     false, respectively.
  useTriggerInfo:    whether to examine the L1/HLT information present in
                     the file (not available for electrons).


Zprime2muResolution
-------------------

The user defines the mass range for the histograms to be produced, and
the number of bins.  The user inputs the ROOT file(s) to be analyzed,
runs the cmsRun job, and various plots are produced in the current
directory in muon_resolution.ps. (See the below section on "histogram
dumping" for details about how to get at the histograms, and to run
this code in parallel.)


Zprime2muAsymmetry
------------------

Here there are a few knobs for the user to turn.  Depending on the Z'
model and mass one wishes to study, an appropriate PSet such as the
ones in data/AsymmetryDataSets.cff must be specified.  (For example,
the Zssm1000 PSet contains parameters appropriate for examining a SSM
Z' at 1 TeV.)  Ignoring the more self-explanatory parameters, the user
must specify:

  genSampleFiles: EDM ROOT files with many events from which the code
                  obtains parameterizations for the relevant variables.
  massDistType:   what form the pdf for the invariant mass distribution
                  should take; for example, if the data is Drell-Yan
                  continuum, the user specifies 1 for a falling
                  exponential fit.
  recSigma:       the sigma of the Gaussians used in the smear which
                  simulates detector resolution; these are obtained from
                  the plots on the last two pages of fitHistos.*.ps
                  (which is written by the code).

Then, the dataSet parameter must be changed to the appropriate PSet
name. Other parameters that can be changed are:

  verbosity:       control the level of debug information dumped;
                   current levels are 0-3 (0 being none, and 3 being
                   too much);
  noFit:           only produce histograms of the data, and do not
                   actually perform any fit; useful for getting the
                   plots to obtain the recSigma information above;
  onlyEvalLLR:     if true, do not do the full fit on the data, but
                   evaluate the log-likelihood ratios, useful for spin
                   discrimination studies (currently disabled);
  fitType:         a magic number which determines the form of the
                   cos_theta_cs pdf used in the fit or evaluation of
                   the likelihood ratio;
  numFits:         how many of the fits to do (default is all 6, which
                   are combinations of generated or reconstructed data,
                   and detector resolution simulation via smearing or
                   not);
  maxParamEvents:  a way to cap the number of events read from
                   genSample, useful if using all events is overkill;
  useCachedParams: flag to enable using the cached parameterization that
                   exists in the file specified by the parameter
                   paramCacheFile, instead of re-calculating the
                   parameterization;
  paramCacheFile:  a ROOT filename in which the parameterization
                   calculation will store its quantities;
  calcParamsOnly:  if enabled, the job will only calculate the
                   parameterization and exit;
  onPeak:          whether to use the on-peak fit window or the off-peak
                   one (see the data set parameters in
                   AsymmetryDataSets.cff);
  internalBremOn:  whether bremsstrahlung was turned on for the generated
                   events;
  fixbIn1DFit:     whether to fix b to the "true" value of 1.0 in the
                   simple 1-D fits, so that the only parameter is A_FB
  useCosTrueInFit: whether to cheat and use MC truth for cos(theta) in
                   the full-blown 2-D/6-D fits for diagnostic purposes;
  artificialCosCS: whether to correct the calculated cos_cs values for
                   mistagging using MC truth;
  correctMistags:  whether to bother using the mistagging probability
                   in the fit at all;
  calculateMistag: whether to calculate the mistag probability omega(y,M)
                   on an event-by-event basis rather than using the
                   parameterization omega(y).

Once the config is set, after running the cmsRun job there will be
various files written to the current directory. These contain various
histograms of the data and the result of the fit. (In the filename,
* is replaced by outputFileBase and other important information.)

  diffFrameAsym.*.ps:
    contains plots of cos_theta in various frames (Gottfried-Jackson,
    Collins-Soper, etc.), and plots of A_{FB} as functions of rapidity
    and mass;
  dumpFitData.*.txt:
    a dump of the six variables that are to be fitted: cos_theta_cs,
    dilepton inv. mass, rapidity, pT, phi, and phi_cs, each both
    at generator level and reconstructed;
  fitHistos.*.ps:
    the data in the previous file histogrammed, as well as resolution
    plots relevant to the asymmetry fit;
  fitParams.*.ps:
    histograms of the info used to calculate the parameterizations,
    and mistag probability information plots;
  frameAsym.*.txt:
    A_{FB} in various frames calculated by a simple counting method
    for each reconstruction level;
  recAsymFit.*.txt:
    contains the mistag parameter information and the results of the
    fits (A_{FB} and errors).


Zprime2muMassReach
------------------

The user is supposed to provide three input files.  The first one is
signal (full-interference Z'), the other two are backgrounds.  The
first background sample is the Drell-Yan generated in the same mass
region as the signal, the second one can be anything but is typically
the Drell-Yan generated at lower masses.  The former background sample
is normally used only for signal-vs-background plots (except for
special applications, when it is used to get a parameterization of the
background slope); the latter gets added to the signal sample
(typically provides events leaking from lower masses to higher
masses).

The user should define a number of parameters for each of the sets in
data/MassReachDataSets.cff.  These parameters include the
cross-sections, K factors, number of generated events (used for
normalizations of certain histograms), and lowerGenMass and
upperGenMass vectors (used to pre-select events based on true dimuon
masses to avoid double-counting).  For the full list of sample-related
parameters, see comments in data/MassReachDataSets.cff.

Parameters defining the analysis flow are in data/Zprime2muMassReach.cfi.
Most of them have special purposes and the default values should not
be modified in the "normal" job.  Notable exceptions are:

- FixedMass and FixedFWHM.  They define whether the resonance mass and
  the resonance width are let float in the fits, or are fixed to some
  reasonable values (default).

- ExpPlots.  If this parameter is set to true, invariant mass distributions
  of individual "pseudo-experiments" and the results of their fits
  will be saved into postscript files in test/mass_plots directory
  (for the first 10 pseudo-experiments).

- intLumi.  Defines the integrated luminosity (in inv. fb) for which the
  user wishes to calculate the mass reach.

The code contains several pre-defined parameterizations used in the
fits, such as of the background slope and of the invariant mass
resolution.  The exact values of the parameters depend on several
factors (CMSSW version, alignment scenario, etc.) and hence should be
tuned for every use case.  The values currently used are essentially
the ones used for the studies in the Physics TDR; we made sure they
give reasonable results for the ideal alignment case in CMSSW_1_3_1,
but have not (re-)tuned them carefully.  One caveat: if one wishes to
study Z' masses other than 1 TeV (3 and 5 TeV are the other two
allowed use cases), one needs to change integration limits in
src/Functions.C (mass_min and mass_max in lorengauPlusExpbckgNorm
method).

The output of the job consists of various dumps in Zprime.out, and two
ps files.  Zmodelmass_sig_back.ps contains signal-vs-background plots;
mass_fits.ps stores the results of the fits (notably various
significance distributions), and some goodness-of-fit distributions
for S+B and B-only hypotheses.


Electron extension
------------------

The flow of the code when running in electron mode is nearly identical
to the muon case, except the extra TeV muon collections are
ignored. The HEEPSelector tool written by D.L. Evans is used to pick
"best" electrons. There is a slight difference in the two code paths,
in that the dimuons constructed have the analysis-level cuts applied
to them at all rec levels, while for dielectrons the analysis-level
cuts are only performed on the "best" electrons, since that is the
output of HEEPSelector. So, in electron mode to study what difference
the HEEP selection makes, one can compare the dileptons at GMR to the
dileptons at OPT. To run in electron mode, pass doingElectrons=True to 
the makeZprime2muAnalysisProcess() function in the Python config file.
(See test/testZprime2muResolutionElectrons_cfg.py for an example.)


Histogram dumping
-----------------

The histograms produced by the code are output in postscript files
by the code itself. This makes it slightly cumbersome to
change the histogram drawing options. To allow easy extraction of the
histograms, we use the TFileService to automatically write histos to
the specified .root file (defined in data/Zprime2muAnalysisCommon.cff,
the default value being "zp2mu_histos.root"). Histograms for
e.g. Zprime2muResolution wind up in a TDirectory of the same name
inside the .root file; see their names in the main code to find the
desired histogram. 

Implementation detail: ROOT automatically deletes the histograms
associated with the file that TFileService creates when the file is
closed, so no explicit delete statements are needed in the code.

Warning: every time you run the code, TFileService will clobber the
.root file specified. Therefore the .root file must be copied out of
the way if it is to be saved.

For Zprime2muResolution, whose output is lots of histograms, this
enables easy parallelization: run Zprime2muResolution jobs with CRAB,
retrieve the zp2mu_histos_X.root files, and hadd to merge them into a
single .root file of histograms.  To get the monolithic postscript
file for the merged collection, re-run one job of Zprime2muResolution
with parameter useHistosFromFile set to true, and with parameter
histoFile set to the filename of the merged .root file. Then the code
will take the histograms from the merged file and draw the postscript,
bypassing the reading of any events in the analyzer.


Step-by-step instructions
-------------------------

To check out the package:

   scramv1 project CMSSW CMSSW_1_6_11
   cd CMSSW_1_6_11/src
   project CMSSW
   cvs co -r V00-01-02 SUSYBSMAnalysis/Zprime2muAnalysis
   # next is needed for fwlite::ChainEvent to read from CASTOR,
   # but the unit test will fail; OK for our purposes
   cvs co -r V00-07-00 DataFormats/FWLite
   # Grab D.L. Evans's HEEPSelector (and put it in the right directory):
   cvs co -r V02-01-02 -d DLEvans/HEEPSelector UserCode/DLEvans/HEEPSelector
   cvs co -r V02-01-01 -d DLEvans/HEEPUtilities UserCode/DLEvans/HEEPUtilities

To compile:

   eval `scramv1 runtime -csh`
   cd SUSYBSMAnalysis/Zprime2muAnalysis
   scramv1 b

To run (where the _cfg.py can be any of the *_cfg.py files in /test):

   cd test
   cmsRun testZprime2muResolution_cfg.py
