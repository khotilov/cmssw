
// PtrelSolver
// Author: Victor E. Bazterra, UIC (2008)

#include "PtrelBySystem4.h"

#include <math.h>
#include <iostream>

#include "TClass.h"
#include "TDirectory.h"
#include "TKey.h"
#include "TFile.h"
#include "TPRegexp.h"

#include "../PtrelSolver/PtrelUtils.h"

ClassImp(PtrelBySystem4)

void PtrelBySystem4::solve(char const * inputfile, char const * outputfile)
{
    Info(__FUNCTION__, "Measuring efficiency");

    // Open a input file
    CreateSafely(TFile, input, TFile::Open(inputfile, "READ"))

    // Open a output file
    CreateSafely(TFile, output, TFile::Open(outputfile, "RECREATE"))

    // Creating sub directory for mesurements results
    if (!output->FindKey("measurements")) output->mkdir("measurements");

    char name[256];

    for (Int_t i = 1; i<Dependency::Dimension; ++i)
    {
        // Collection of flavor content n in sample
        ValueVector nValues;
        ValueVector nErrors;

        // Name for the n samples : n_(pT|eta)
        sprintf(name, "%s/n_%s", directory, Dependency::Name[i]);
        // Measure the flavor content in n sample
        CallSafely( measure(input, output, name, nValues, nErrors) )

        // Collection of flavor content p in sample
        ValueVector pValues;
        ValueVector pErrors;

        // Name for the p samples : p_(pT|eta)
        sprintf(name, "%s/p_%s", directory, Dependency::Name[i]);
        // Measure the flavor content in n sample
        CallSafely( measure(input, output, name, pValues, pErrors) )

        // Collection of counting in ntag samples
        StringVector ntagNames;
        ValueVector ntagValues;
        ValueVector ntagErrors;

        // Name for the ntag samples : ntag_(pT|eta)_[A-Z]*$
        sprintf(name, "ntag_%s_[A-Z]*$", Dependency::Name[i]);
        // Count the number of entries in ntag samples
        CallSafely( count(input, output, TPRegexp(name), ntagNames, ntagValues, ntagErrors) )

        // Collection of counting in ptag samples
        StringVector ptagNames;
        ValueVector ptagValues;
        ValueVector ptagErrors;

        // Name for the ptag samples : ptag_(pT|eta)_[A-Z]*$
        sprintf(name, "ptag_%s_[A-Z]*$", Dependency::Name[i]);
        // Count the number of entries in ptag samples
        CallSafely( count(input, output, TPRegexp(name), ptagNames, ptagValues, ptagErrors) )

        // HACK to force reading the objets from file
        // Close output
        input->Close();
        // Reopen
        GetSafely(input, TFile::Open(inputfile, "READ"))
        // ENDHACK

        // Get a 2D histogram to produce a place holder for the results later
        sprintf(name, "%s/n_%s", directory, Dependency::Name[i]);
        CreateSafely(TH2D, histogram2D, readTH2(input, name))
        
        for (std::size_t j = 0; j < ptagNames.size(); ++j)
                {   
                	// Collect the tag names
      	            TPRegexp t("[A-Z]{3,}");
            
                    Int_t inx = ntagNames[j].Index(t);
                    std::string tmp(ntagNames[j].Data());
                    std::string tagA(tmp.substr(inx, tmp.size()));

                    inx = ptagNames[j].Index(t);
                    tmp = ptagNames[j].Data();
                    std::string tagB(tmp.substr(inx, tmp.size()));
                	             	
                	// Read the beta coefficients
        	        sprintf(
        	                name, "coefficients/coefficient_mctruth_n_%s_b_ntag_%s_b_%s_mctruth_p_%s_b_ptag_%s_b_%s", 
        	                Dependency::Name[i], Dependency::Name[i], tagA.c_str(), Dependency::Name[i], Dependency::Name[i], tagB.c_str()
        	        );
        	        
        	        std::cout << name << std::endl;
        	    
                	CreateSafely( TH1D, betaHistogram, templates_->Get(name) )

                	// Read the beta coefficients
        	        sprintf(
        	                name, "coefficients/coefficient_mctruth_n_%s_b_ntag_%s_b_%s_mctruth_p_%s_b_ptag_%s_b_%s", 
        	                Dependency::Name[i], Dependency::Name[i], tagA.c_str(), Dependency::Name[i], Dependency::Name[i], tagB.c_str()
        	        );
                	CreateSafely( TH1D, alfaHistogram, templates_->Get(name) )

                }                	


    }

    input->Close();
    output->Close();
}


bool PtrelBySystem4::count(
    TFile * input,
    TFile * output,
    TPRegexp pattern,
    StringVector & hVector,
    ValueVector & vVector,
    ValueVector & eVector
) const
{
    // Return status
    bool status = false;

    // Clean the containers
    hVector.clear();
    vVector.clear();
    eVector.clear();

    // Move to the directory with 2d histograms
    input->cd(directory);

    // Loop over all keys in this directory
    TIter nextkey( gDirectory->GetListOfKeys() );

    TKey * key;

    char name[256];

    while (( key = (TKey*)nextkey() ))
    {
        // Measure those 2D histogram with name fit the pattern
        TObject * object = key->ReadObj();
        if ( object->IsA()->InheritsFrom( "TH2" ) )
            if ( TString(object->GetName() ).Contains(pattern) )
            {
                // Update status
                status = true;

                // Temporal container for efficiencies
                TH2 * histogram2D;

                // Process 2D histogram associated to the keyword
                GetSafelyZero(histogram2D, processTH2(object))

                // Get the number of bins in X direction
                Int_t nbins = histogram2D->GetNbinsX();

                // Temporal container with the results
                TVectorD values(nbins), errors(nbins);
          
                // Info
                Info(__FUNCTION__, "Counting the number of events in %s", histogram2D->GetName());
                
                // Loop over the bins
                for (Int_t i = 1; i <= nbins; ++i)
                {
                    // Set histogram name by the formula = data_x_bin (transient)
                    sprintf(name, "count_%s_%d", histogram2D->GetName(), i);
                    // Project histogram
                    TH1D * histogram1D = histogram2D->ProjectionY(name, i, i, "e");

                    // Appending the results
                    values(i-1) = histogram1D->Integral();
                    errors(i-1) = 0.0;
                }   
                hVector.push_back(TString(histogram2D->GetName()));
                vVector.push_back(values);
                eVector.push_back(errors);
            }
    };

    if (!status) Error(__FUNCTION__, "Non matching histograms were found");

    return status;
}


/*bool PtrelBySystem4::compute(
    TH1 * histogram,
    ValueVector const & factors,
    TVectorD const & ntagCounters,
    TVectorD const & ptagCounters,
    ValueVector const & nValues,
    ValueVector const & nCovariance,
    ValueVector const & pValues,
    ValueVector const & pCovariance
)
{
    // Loop over different bins
    for (std::size_t i = 0; i < nValues.size(); ++i)
    {
    	Double_t n_tag = ntagCounters[i];
        Double_t n_b = nValues[i](Flavor::b);
        Double_t n_cl = nValues[i](Flavor::cl);
    	Double_t p_tag = ptagCounters[i];
        Double_t p_b = ptagValues[i](Flavor::b);
        Double_t p_cl = ptagValues[i](Flavor::cl);

        // Double_t n_cl_error = nCovariance[i](Flavor::cl, Flavor::cl);
        // Double_t p_b_error = ptagCovariance[i](Flavor::b, Flavor::b);

        Double_t alfa = factors[i][Flavor::cl];
        Double_t beta = factors[i][Flavor::b];

        histogram->SetBinContent(i+1, (alfa*n_tag*p_cl - p_tag*n_cl)/(alfa*n_b*p_cl - beta*n_cl*p_b));
    }
    return true;
}
*/
