#include "RKAdaptiveSolver.h"
#include <cmath>


template <typename T, 
	  template <typename,int> class StepWithPrec, 
	  int N>
typename  RKAdaptiveSolver<T, StepWithPrec, N>::Vector
RKAdaptiveSolver<T,StepWithPrec,N>::operator()( Scalar startPar, const Vector& startState,
						     Scalar step, const RKDerivative<T,N>& deriv,
						     const RKDistance<T,N>& dist,
						     float eps)
{
  const float Safety = 0.9;
  double remainigStep = step;
  double stepSize = step;   // attempt to solve in one step
  Scalar currentPar   = startPar;
  Vector currentStart = startState;
  int nsteps = 0;
  std::pair<Vector, Scalar> tryStep;
  
  StepWithPrec<T,N> stepWithAccuracy;
  
  do {
    tryStep = stepWithAccuracy( currentPar, currentStart, deriv, dist, stepSize);
    float acc = tryStep.second;
    assert(eps>0);
    assert(acc>=0);
    nsteps++;
    if (acc <eps) {
      if (std::abs(remainigStep - stepSize) < 0.5*eps) {
	//	if (verbose()) std::cout << "Accuracy reached, and full step taken in " 
	//		    << nsteps << " steps" << std::endl;
	return tryStep.first; // we are there
      } else {
	remainigStep -= stepSize;
	currentPar += stepSize;
	// increase step size
	// double factor =  std::min( Safety * pow( std::fabs(eps/tryStep.second),0.2), 4.); // gives division by 0 FPE
	float factor =  acc == 0 ? 4.f : std::min( Safety * std::pow(eps/acc,0.2f), 4.f);
      
	// stepSize = std::min( stepSize*factor, remainigStep);
	double absSize =  std::min( std::abs(stepSize*factor), std::abs(remainigStep));
	stepSize = std::copysign(absSize,stepSize);
	currentStart = tryStep.first;
	//if (verbose()) std::cout << "Accuracy reached, but " << remainigStep 
	//     << " remain after " << nsteps << " steps. Step size increased by " 
	//     << factor << " to " << stepSize << std::endl;
      }
    }    else {
      // decrease step size
      float factor = 
	( (Safety*Safety*Safety*Safety*100*100)*eps > acc) ?
	Safety * std::sqrt(std::sqrt(eps/acc)) : 0.1f;
      stepSize *= factor;
      // if (verbose()) std::cout << "Accuracy not yet reached: delta = " << tryStep.second
      //	 << ", step reduced by " << factor << " to " << stepSize << std::endl;
    }
  } while (std::abs(remainigStep) > eps*0.5f);
  
  return tryStep.first;
}
