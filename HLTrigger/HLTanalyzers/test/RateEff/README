README for OpenHLT rate and Efficiencies calculating scripts

  Chi-Nhan Nguyen <chinhan@cern.ch>
  Jonathan Hollar <jjhollar@cern.ch>
  Pedrame Bargassa <bargassa@cern.ch>
  Silvia Goy Lopez <goylopez@cern.ch>

************************************** 
1. Introduction
************************************** 



--------------------------------------  
1a. Running the scripts
--------------------------------------  
 
  Once the binary file is built, the rate-calculating script can be run using:
  
  ./OHltRateEff <cfgfile> 

  Some arguments in the cfg file are as follows (see example hltmenu_1E31_2008Dec04.cfg):
  [incomplete docu here!]
    
    nEntries: Number of events to run over.
          That number will be used for each sample.
          If there exist less events in a sample than requested than the script
          will run over all existing.
          Any number < 0 will be interpreted as "running over all existing events".
          Default is all (-1).
  
    versionTag: A string describing this menu. This will be appended to the name of the output files.
          
    doPrintAll: If set to 1 all printouts incl. overlap coefficient etc,
            and also the TeX file is generated.
            Otherwise only the most basic  info is printed out to stdout.
    
    

**************************************
2. Input samples and cross-sections
**************************************
  Samples are registered via the process tag, example:

	process:{
 		names = ["minbias","qcdpt30"]; # arbitrary names
 		paths = ["/uscmst1b_scratch/lpc1/lpctrig/apana/data/MinBias/lumi8e29/",
			"/uscmst1b_scratch/lpc1/lpctrig/apana/data/QCDpt30/lumi8e29/];
			# paths to set of files
 		fnames = ["Summer08_MinBias*root","Summer08_QCDpt30*root"];
			# list of filenames, asterisks can be used
 		doMuonCuts = [false];
			# against muon double counting, only used for special case
			# if enriched muon samples are used with minbias samples, otherwise always 'false'
 		doElecCuts = [false]; #
			# against electron double counting, only used for special case
			# if enriched electron samples are used with minbias, otherwise always 'false'
 		sigmas = [7.53E10,1E8]; # 10 TeV xsecs * filter efficiencies
	};


**************************************
3. Trigger examples
**************************************

-------------------------------------- 
3a. Adding new OpenHLT triggers
-------------------------------------- 

        To add a new OpenHLT trigger, the first step is to register it in the 
	cfg file:  
	triggers = ( 
		("HLT_L1MuOpen","L1_SingleMu OR L1_SingleMuOpen", 5, 1.5),
	...
	) 
 
        Where the items denote the name, the logical expression of the L1 seeds,
	the prescale and the eventsize (MB) of that trigger. 
	L1 condition of the trigger is parsed by using the L1GtLogicParser also
	used for HLTLevel1GTSeed. Hence, you can use any kind of logic expressions like:
	"(L1_SingleMu OR L1_SingleMuOpen) AND L1_SingleMu3".

	If you run on samples with unprescaled L1 triggers, you can simulate the L1 prescale
	by running a preloop sequence with: doL1preloop = true.
	In that case you also have to provide the list of L1 triggers and prescales, example:


	 	L1triggers = ( 
			#
  			("L1_SingleMu0", 1),
			...
		);


	Once the trigger is registered, the actual trigger logic must be implemented in OHltTreeOpen.cpp;
	this is done in two places.
	The first is the OHltTree::CheckOpenHlt method, where the L1 and HLT pass/fail conditions
	are decided.
  	The second is in dedicated methods where the HLT trigger algorithms are emulated.
	A single one of these dedicated
  	methods can be used by several OpenHLT triggers if they differ only in their thresholds. 

  	Several example OpenHLT triggers are provided as templates; these are described in detail below.

--------------------------------------  
3b. Example OpenHLT jet triggers  
--------------------------------------  
 
        One example OpenHLT jet trigger (corresponding to HLT1jet) is implemented. The algorithm is  
        implemented in the OHltTree::OpenHlt1JetPassed method. This method takes a single argument:

    double pt:  Jet pT threshold.

  The trigger passes if N>=1 jets above threshold are found in the event. 

--------------------------------------
3c. Example OpenHLT muon triggers
--------------------------------------
  
  Three example OpenHLT muon triggers (corresponding to HLT1MuonNonIso, HLT1MuonIso, and HLT2MuonNonIso) are 
  available. 

  The algorithm for the single muon triggers is implemented in the OHltTree::OpenHlt1MuonPassed method. This 
  takes five arguments:

    double ptl1:  L1extra pT threshold 
    double ptl2:  L2 muon pT threshold
    double ptl3:  L3 muon pT threshold
    double dr:  L3 dR threshold
    int iso:  L3 isolation (1 if isolated, 0 if non-isolated)

  The algorithm starts from L3 muons and applies pT, eta, dr, and isolation criteria. It 
  then finds the L2 muon matched to the L3 muon, and applies pT and eta cuts. It then finds
  the L1extra muon most closely matched to the L2 muon, and applies pT and quality cuts. For the 
  single muon triggers, the L1 quality must be between 4 and 7 (inclusive). The trigger passes if 
  N>=1 muons satisfying all these criteria are found.

  The algorithm for the double muon triggers is implemented in the OHltTree::OpenHlt2MuonPassed 
  method. The arguments to this method are:

          double ptl1:    L1extra pT threshold  
                double ptl2:    L2 muon pT threshold 
                double ptl3:    L3 muon pT threshold 
                double dr:      L3 dR threshold 
                int iso:        L3 isolation (1 if isolated, 0 if non-isolated) 

  The algorithm is identical to the single muon case described above, with the exception of the L1extra muons, 
  which must have quality between 3 and 7 (inclusive). The trigger passes if N>=2 muons satisfying all these 
  criteria are found.

  * Note that in CMSSW releases 2_X and higher, the L2 and L3 muon pT thresholds are implemented as flat cuts.
    In earlier releases, the thresholds were implemented as 90% CL upper limits. OpenHLT examples of the old pT 
    threshold implementation are found at the beginning of the OpenHlt1MuonPassed and OpenHlt2MuonPassed examples.


--------------------------------------
3d. Example OpenHLT electron triggers
--------------------------------------
  
  One example OpenHLT electron trigger (HLT1Electron) are available. 

  The algorithm for the single electron triggers is implemented in the OHltTree::OpenHlt1ElectronPassed method.
        This takes five arguments:

    float   Et: Et threshold in GeV
    int   L1iso:  L1 is isolated (1: yes, 0: no)
    float Tiso: Track isolation in GeV
    float Hiso: Hcal isolation in GeV

  In the example code some cuts are mandatory and cannot be varied.
  They have the following default values:
    ohEleNewSC[i]>0                 : Is 1, if electron found by Super Cluster Algo, otherwise 0
    ohEleHiso[i]/ohEleEt[i] < 0.05  : Hadronic fraction smaller than 0.05
    ohElePixelSeeds[i]>0    : Pixel seed found or not (1 or 0)

--------------------------------------
3e. Example OpenHLT photon triggers
--------------------------------------
  
  One example OpenHLT electron trigger (HLT1Electron) are available. 

  The algorithm for the single electron triggers is implemented in the OHltTree::OpenHlt1ElectronPassed method.
        This takes five arguments:

    float   Et: Et threshold in GeV
    int   L1iso:  L1 is isolated (1: yes, 0: no)
    float Tiso: Track isolation in GeV
    float Eiso: Ecal isolation in GeV
    float HisoBR: Barrel Hcal isolation in GeV
    float HisoEC: Endcap Hcal isolation in GeV


--------------------------------------
3f. Example OpenHLT tau triggers
--------------------------------------
  
  Several examples are available in OHltTree.cpp. 

  The algorithm for the Tau triggers is implemented in OHltTree::OpenHltTauPassed method.
        As an example one can take the HLT2TauPixel path, which can be implemented as

  if(OpenHltTauPassed(15.,5.,3.,1,0.,0)>=2) {} using
        OpenHltTauPassed(float Et,float Eiso, float L25Tpt, int L25Tiso, float L3Tpt, int L3Tiso)

  The if statement asks for at least 2 tau candidates which fullfil both these criteria:        

    float   Et: L2 calo Et threshold in GeV
    int   Eiso: L2 is Ecal isolated (1: yes, 0: no)
    float L25Tpt: L2.5 pixel leading Track Pt threshold in GeV
    int   L25Tiso:  L2.5 is Track isolated (1: yes, 0: no)
    float L3Tpt:  L3 si+pix leading Track Pt threshold in GeV
    int   L3Tiso: L3 is Track isolated (1: yes, 0: no)





Efficiency and PD parts to be implemented, old description below:

--------------------------------------
3. Efficiency code
--------------------------------------

  Once the HLT paths of interest are defined (either as 'standard' HLT paths or in OpenHLT) 
  they must be inserted in the corresponding trigger menu using the menu->AddHlt() function.
  At this step one must define the multiplicity of the relevant objects (electron,photon,muon,
  jet,met) for booking of efficiency histograms.

  Then the script must be run with settings:
    RateOnly=0, EfficiencyOnly=1 (runs only efficiency code on signal samples)
    RateOnly=1, EfficiencyOnly=0 (runs efficiency and rate code on both background and
                signal samples)

  Histograms are filled with reconstructed pt,eta and phi of requested objects 
    1) For all events in the input file
    2) For all events passing the L1 seed corresponding to each HLT path
    3) For all events passing the HLT paths

  Efficiency histograms are filled dividing 3)/1) (overall HLT efficiency) and 3)/2) (HLT 
  efficiency wrt L1)
  
  The output consists one root file per sample with efficiency histograms and a printout with global
  integrated numbers. 

  For more details see:
  http://indico.cern.ch/materialDisplay.py?contribId=12&sessionId=1&materialId=slides&confId=41546
  
  In case of missing functionalities, please contact goylopez@cern.ch


--------------------------------------
4. Primary Datasets code
--------------------------------------

  The primary datasets evaluation happens as part of the event loop. Its purpose is to
    1) Evaluate the rates of datasets, correlation (i.e. fraction of shared events) between 
       datasets, and total output overhead for storing datasets. 
    2) Evaluate the correlation of "new triggers" with the primary datasets, and also the
       rate of unique events that can be added by a particular new trigger to each of the
       primary datasets, if it were to be placed in that location.
       
  The "new triggers" are defined to be all the triggers that do not appear in one or more
  primary datasets, as read from the <sPrimaryDatasets> input file. As mentioned, if
  <sPrimaryDatasets> = "" is provided, every trigger is considered to be a dataset (so, 
  there are _no_ new triggers) -- this is useful for outputting the trigger-vs-trigger
  correlation plot, which can help you diagnose whether your proposed trigger has already
  been (mostly) superceded by some other trigger(s).
  
  The code produces two output files:
    a) X_scenario_correlations.root : a few histograms (one per sample, and for "all", "rate",
                                      and "physics" combinations of samples) with the 2D 
                                      correlation plots that can be used for deciding which 
                                      triggers go into which datasets.
    b) X_scenario_correlations.pdf  : essentially the same information as (a), but in numerical 
                                      form (tables). Specifically, this shows the rate that 
                                      would be added by each trigger, if it were to be added to 
                                      a particular dataset.
  Here X is the same as the OHltRateEff main output name.
  
