#!/usr/bin/env python

import sys
import os
import re
import commands
import getopt
import shlex, subprocess
import argparse, textwrap


# available "type"s and relative global tags
globalTag = {
  'FULL': 'auto:startup',
  'GRun': 'auto:startup',       # use as default
  'data': 'auto:hltonline',
  'HIon': 'auto:startup',
}


# define a class to store all options and arguments
class Configuration(object):
  pass

configuration = Configuration()


# argparse's formatters remove newlines from comand descriptions, so we define a new one
class HelpFormatterRespectNewlines(argparse.HelpFormatter):
    """Help message formatter which retains line breaks in argument descriptions.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    def _split_lines(self, text, width):
        lines = []
        for line in text.splitlines():
          line = self._whitespace_matcher.sub(' ', line).strip()
          lines.extend( textwrap.wrap(line, width) )
        return lines

# argparse's formatters are not really able to discover the terminale size, so we override them
def FixedWidthFormatter(formatter, width):
  def f(*args, **keywords):
    # add or replace the "width" parameter
    keywords['width'] = width
    return formatter(*args, **keywords)

  return f

textwidth = int( os.popen("stty size", "r").read().split()[1] )
formatter = FixedWidthFormatter( HelpFormatterRespectNewlines, width = textwidth )


# type used to store a reference to an L1 menu
class MenuL1(object):
  def __init__(self, value):
    self.override = None
    self.connect  = None

    # extract the connection string and configuration name
    if value:
      if ':' in value:
        self.override = "L1GtTriggerMenu_%s_mc" % value.rsplit(':', 1)[1]
        self.connect  = '"%s"' % value.rsplit(':', 1)[0]
      else:
        self.override = "L1GtTriggerMenu_%s_mc" % value
        self.connect  = None


# type used to store a reference to an HLT configuration
class MenuHLT(object):
  def __init__(self, value):
    self.value  = value
    self.db     = None
    self.name   = None
    self.run    = None

    # extract the database and configuration name
    if value:
      if ':' in self.value:
        (db, name) = self.value.split(':')
        if db == 'run':
          self.run  = name
        elif db in ('hltdev', 'orcoff'):
          self.db   = db
          self.name = name
        else:
          print 'Unknown ConfDB database "%s", valid values are "hltdev" (default) and "orcoff")' % db
          sys.exit(1)
      else:
        self.db   = 'hltdev'
        self.name = self.value


# define an argparse parser to parse our options
parser = argparse.ArgumentParser(
  description       = 'Extract an HLT configuration (or fragment thereof) from the ConfDB database.''',
  epilog            = 'Note: using "--online", overriding the GlobalTag or the L1 menu  is meaingful only in a full, self-contained dump. A cff file does not provide the modules to be overriden.''', 
  argument_default  = argparse.SUPPRESS,
  formatter_class   = formatter,
  add_help          = False )

# required argument
parser.add_argument('menuConfig',
                    action  = 'store', 
                    type    = MenuHLT,
                    metavar = 'MENU', 
                    help    = 'HLT menu to dump from the database. Supported formats are:\n- [hltdev:]/path/to/configuration[/Vn]\n- orcoff:/path/to/configuration[/Vn]\n- run:runnumber\nThe possible databases are "hltdev" (default, used for offline development) and "orcoff:" (ued for online menus). If no version is specified, the latest one is automatically used.\nIf "run:" is used instead, the actual HLT menu for thegiven run number is looked up and used.' )

# options
parser.add_argument('--process', 
                    dest    = 'processName', 
                    action  = 'store', 
                    default = 'HLT', 
                    metavar = 'PROCESS', 
                    help    = 'Override the process name (the default is %(default)s)' )
parser.add_argument('--type', 
                    dest    = 'processType', 
                    action  = 'store', 
                    metavar = 'TYPE', 
                    choices = globalTag, 
                    default = None,
                    help    = 'Set global options acording to a specific HLT luminosity and type (%(choices)s).' )
parser.add_argument('--globaltag', 
                    dest    = 'menuGlobalTag', 
                    action  = 'store', 
                    metavar = 'TAG', 
                    default = None,
                    help    = 'Override the GlobalTag in the HLT menu:\n- when running on data, the default behaviour is to not override the GobalTag in the HLT menu;\n- when running on MC, the default behaviour is to use the GlobalTag from "type" and the current PyRelVal configuration.\nTo run on data with a different release than the menu was designed for, try "auto:hltonline"' )
parser.add_argument('--l1', 
                    dest    = 'menuL1', 
                    action  = 'store',
                    type    = MenuL1,
                    default = MenuL1(None),
                    metavar = 'MENU', 
                    help    = 'Override the L1 menu, using the payload "L1GtTriggerMenu_<%(metavar)s>_mc" from the database.\nThe default behaviour is to run with the L1 menu from the GlobalTag' )
parser.add_argument('--unprescale', 
                    dest    = 'menuUnprescale', 
                    action  = 'store_true', 
                    default = False, 
                    help    = 'Run without any HLT prescales' )
parser.add_argument('--dataset', 
                    dest    = 'menuDataset', 
                    action  = 'store', 
                    metavar = 'DATASET',
                    default = None,
                    help    = 'Take the input files from the specified %(metavar)s' )

group = parser.add_mutually_exclusive_group()
group.add_argument('--data', 
                    dest    = 'runOnData', 
                    action  = 'store_true', 
                    default = True, 
                    help    = 'Prepare a menu for running on data (raw events in "source") (default)' )
group.add_argument('--mc', 
                    dest    = 'runOnData', 
                    action  = 'store_false', 
                    help    = 'Prepare a menu for running on MC (raw events in "rawDataCollector")' )

group = parser.add_mutually_exclusive_group()
group.add_argument('--full', 
                    dest    = 'doCff', 
                    action  = 'store_false', 
                    default = False, 
                    help    = 'Generate a full configuration file, with minimal modifications (default)' )
group.add_argument('--cff', 
                    dest    = 'doCff', 
                    action  = 'store_true', 
                    help    = 'Generate a stripped down configuration file fragment, for inclusion by e.g. cmsDriver.py' )

group = parser.add_mutually_exclusive_group()
group.add_argument('--online', 
                    dest    = 'runOnline', 
                    action  = 'store_true', 
                    help    = 'Generate a configuration file suitable for running online (use the online compliant connection string)' )
group.add_argument('--offline', 
                    dest    = 'runOnline', 
                    action  = 'store_false', 
                    default = False, 
                    help    = 'Generate a configuration file suitable for running offline (override the connection string) (default)' )

# redefine "--help" to be the last option, and use a customized message 
parser.add_argument('--help', 
                    action  = 'help', 
                    help    = 'Show this help message and exit' )



# wrapper around subprocess to simplify te interface
def pipe(cmdline, input = None):
  args = shlex.split(cmdline)
  if input is not None:
    command = subprocess.Popen(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=None)
  else:
    command = subprocess.Popen(args, stdin=None, stdout=subprocess.PIPE, stderr=None)
  (out, err) = command.communicate(input)
  return out


class HltMenu(object):
  def __init__(self):
    self.data     = None
    self.labels   = {}

  @staticmethod
  def _build_query(config):
    if config.run:
      return '--runNumber %s' % config.run
    else:
      return '--%s --configName %s' % (config.db, config.name)

  @staticmethod
  def _build_source(src):
    if src is None:
      return '--noedsources'
    else:
      return '--input ' + src

  @staticmethod
  def _build_options(opts):
    return ' '.join(['--%s %s' % (key, ','.join(vals)) for key, vals in opts.iteritems() if vals])

  def _build_cmdline(self, config, src, opts, fragment):
    if not fragment:
      return 'edmConfigFromDB %s %s %s'       % (self._build_query(config), self._build_source(src), self._build_options(opts))
    else:
      return 'edmConfigFromDB --cff %s %s %s' % (self._build_query(config), self._build_source(src), self._build_options(opts))

  def getRawConfigurationFromDB(self, config, src, opts, fragment):
    if fragment:
      self.labels['process'] = ''
      self.labels['dict']    = 'locals()'
    else:
      self.labels['process'] = 'process.'
      self.labels['dict']    = 'process.__dict__'

    cmdline = self._build_cmdline(configuration.menuConfig, confdbSource, confdbOptions, fragment)
    data = pipe(cmdline)
    
    if 'Exhausted Resultset' in data or 'CONFIG_NOT_FOUND' in data:
      raise ImportError('%s is not a valid HLT menu' % configuration.menuConfig.value)

    self.data = data


  def fixForMC(self):
    # override the raw data collection label
    self.data = re.sub( r'cms\.InputTag\( "source" \)',            r'cms.InputTag( "rawDataCollector" )',           self.data)
    self.data = re.sub( r'cms\.untracked\.InputTag\( "source" \)', r'cms.untracked.InputTag( "rawDataCollector" )', self.data)
    self.data = re.sub( r'cms\.string\( "source" \)',              r'cms.string( "rawDataCollector" )',             self.data)

    # override the preshower baseline setting for MC - needed for 3.5.x (x >= 7) and 3.6.x
    self.data += """
# override the preshower baseline setting for MC
if 'ESUnpackerWorkerESProducer' in %(dict)s:
    %(process)sESUnpackerWorkerESProducer.RHAlgo.ESBaseline = 1000
""" % self.labels


  def unprescale(self):
    self.data += """
# remove the HLT prescales
if 'PrescaleService' in %(dict)s:
    %(process)sPrescaleService.lvl1DefaultLabel = cms.untracked.string( '0' )
    %(process)sPrescaleService.lvl1Labels = cms.vstring( '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' )
    %(process)sPrescaleService.prescaleTable = cms.VPSet( )
""" % self.labels


  def overrideGlobalTag(self, configuration):
    # overwrite GlobalTag
    # the logic is:
    #   - for running online, do nothing, unless a globaltag has been specified on the command line
    #   - for running offline on data, only add the pfnPrefix
    #   - for running offline on mc, take the GT from the command line of the configuration.processType
    #      - if the GT is "auto:...", insert the code to read it from Configuration.PyReleaseValidation.autoCond
    text = ''
    if configuration.runOnline:
      if configuration.menuGlobalTag:
        text += """
# override the GlobalTag 
if 'GlobalTag' in %%(dict)s:
    %%(process)sGlobalTag.globaltag = '%(menuGlobalTag)s'
"""

    else:
      text += """
# override the GlobalTag connection string and pfnPrefix
if 'GlobalTag' in %%(dict)s:
"""

      # override the GlobalTag connection string and pfnPrefix
      text += "    %%(process)sGlobalTag.connect   = 'frontier://FrontierProd/CMS_COND_31X_GLOBALTAG'\n"
      text += "    %%(process)sGlobalTag.pfnPrefix = cms.untracked.string('frontier://FrontierProd/')\n"

      if configuration.runOnData:
        # do not override the GlobalTag unless one was specified on the command line 
        pass
      else:
        # check if a specific GlobalTag was specified on the command line, or choose one from the configuration.processType
        if not configuration.menuGlobalTag:
          if configuration.processType in globalTag:
            configuration.menuGlobalTag = globalTag[configuration.processType]
          else:
            configuration.menuGlobalTag = globalTag['GRun']

      # check if the GlobalTag is an autoCond or an explicit tag
      if not configuration.menuGlobalTag:
        # when running on data, do not override the GlobalTag unless one was specified on the command line
        pass
      elif configuration.menuGlobalTag[0:5] == 'auto:':
        configuration.menuGlobalTagAuto = configuration.menuGlobalTag[5:]
        text += "    from Configuration.PyReleaseValidation.autoCond import autoCond\n"
        text += "    %%(process)sGlobalTag.globaltag = autoCond['%(menuGlobalTagAuto)s']\n"
      else:
        text += "    %%(process)sGlobalTag.globaltag = '%(menuGlobalTag)s'\n"

    self.data += text % configuration.__dict__


  def overrideL1Menu(self, configuration):
    # if requested, override the L1 menu from the GlobalTag (using the same connect as the GlobalTag itself)
    if configuration.menuL1.override:
      if not configuration.menuL1.connect:
        configuration.menuL1.connect = "%(process)sGlobalTag.connect.value().replace('CMS_COND_31X_GLOBALTAG', 'CMS_COND_31X_L1T')"
      menu.data += """
# override the L1 menu
if 'GlobalTag' in %%(dict)s:
    %%(process)sGlobalTag.toGet.append(
        cms.PSet(  
            record  = cms.string( "L1GtTriggerMenuRcd" ),
            tag     = cms.string( "%(override)s" ),
            connect = cms.untracked.string( %(connect)s )
        )
    )
""" % configuration.menuL1.__dict__



# parse command line arguments and options
args = parser.parse_args( namespace = configuration )

# Initialize everything
confdbOptions = {
    'essources' : [],
    'esmodules' : [],
    'modules'   : [],
    'services'  : [],
    'paths'     : [],
    'psets'     : [],
}

confdbSource = None
menu = HltMenu()

if configuration.doCff:
    confdbOptions['essources'].append( "-GlobalTag" )
    confdbOptions['essources'].append( "-Level1MenuOverride" )
    confdbOptions['essources'].append( "-HepPDTESSource" )
    confdbOptions['essources'].append( "-XMLIdealGeometryESSource" )
    confdbOptions['essources'].append( "-eegeom" )
    confdbOptions['essources'].append( "-es_hardcode" )
    confdbOptions['essources'].append( "-magfield" )

    confdbOptions['esmodules'].append( "-AutoMagneticFieldESProducer" )
    confdbOptions['esmodules'].append( "-SlaveField0" )
    confdbOptions['esmodules'].append( "-SlaveField20" )
    confdbOptions['esmodules'].append( "-SlaveField30" )
    confdbOptions['esmodules'].append( "-SlaveField35" )
    confdbOptions['esmodules'].append( "-SlaveField38" )
    confdbOptions['esmodules'].append( "-SlaveField40" )
    confdbOptions['esmodules'].append( "-VBF0" )
    confdbOptions['esmodules'].append( "-VBF20" )
    confdbOptions['esmodules'].append( "-VBF30" )
    confdbOptions['esmodules'].append( "-VBF35" )
    confdbOptions['esmodules'].append( "-VBF38" )
    confdbOptions['esmodules'].append( "-VBF40" )
    confdbOptions['esmodules'].append( "-CSCGeometryESModule" )
    confdbOptions['esmodules'].append( "-CaloGeometryBuilder" )
    confdbOptions['esmodules'].append( "-CaloTowerGeometryFromDBEP" )
    confdbOptions['esmodules'].append( "-CaloTowerHardcodeGeometryEP" )
    confdbOptions['esmodules'].append( "-CastorGeometryFromDBEP" )
    confdbOptions['esmodules'].append( "-CastorHardcodeGeometryEP" )
    confdbOptions['esmodules'].append( "-DTGeometryESModule" )
    confdbOptions['esmodules'].append( "-EcalBarrelGeometryEP" )
    confdbOptions['esmodules'].append( "-EcalBarrelGeometryFromDBEP" )
    confdbOptions['esmodules'].append( "-EcalElectronicsMappingBuilder" )
    confdbOptions['esmodules'].append( "-EcalEndcapGeometryEP" )
    confdbOptions['esmodules'].append( "-EcalEndcapGeometryFromDBEP" )
    confdbOptions['esmodules'].append( "-EcalLaserCorrectionService" )
    confdbOptions['esmodules'].append( "-EcalPreshowerGeometryEP" )
    confdbOptions['esmodules'].append( "-EcalPreshowerGeometryFromDBEP" )
    confdbOptions['esmodules'].append( "-HcalGeometryFromDBEP" )
    confdbOptions['esmodules'].append( "-HcalHardcodeGeometryEP" )
    confdbOptions['esmodules'].append( "-HcalTopologyIdealEP" )
    confdbOptions['esmodules'].append( "-MuonNumberingInitialization" )
    confdbOptions['esmodules'].append( "-ParametrizedMagneticFieldProducer" )
    confdbOptions['esmodules'].append( "-RPCGeometryESModule" )
    confdbOptions['esmodules'].append( "-SiStripGainESProducer" )
    confdbOptions['esmodules'].append( "-SiStripRecHitMatcherESProducer" )
    confdbOptions['esmodules'].append( "-SiStripQualityESProducer" )
    confdbOptions['esmodules'].append( "-StripCPEfromTrackAngleESProducer" )
    confdbOptions['esmodules'].append( "-TrackerDigiGeometryESModule" )
    confdbOptions['esmodules'].append( "-TrackerGeometricDetESModule" )
    confdbOptions['esmodules'].append( "-VolumeBasedMagneticFieldESProducer" )
    confdbOptions['esmodules'].append( "-XMLFromDBSource" )
    confdbOptions['esmodules'].append( "-ZdcGeometryFromDBEP" )
    confdbOptions['esmodules'].append( "-ZdcHardcodeGeometryEP" )
    confdbOptions['esmodules'].append( "-hcal_db_producer" )
    confdbOptions['esmodules'].append( "-l1GtTriggerMenuXml" )
    confdbOptions['esmodules'].append( "-L1GtTriggerMaskAlgoTrigTrivialProducer" )
    confdbOptions['esmodules'].append( "-L1GtTriggerMaskTechTrigTrivialProducer" )
    confdbOptions['esmodules'].append( "-sistripconn" )

    confdbOptions['services'].append( "-PrescaleService" )
    confdbOptions['services'].append( "-MessageLogger" )
    confdbOptions['services'].append( "-DQM" )
    confdbOptions['services'].append( "-DQMStore" )
    confdbOptions['services'].append( "-FUShmDQMOutputService" )
    confdbOptions['services'].append( "-MicroStateService" )
    confdbOptions['services'].append( "-ModuleWebRegistry" )
    confdbOptions['services'].append( "-TimeProfilerService" )

    confdbOptions['paths'].append( "-HLTOutput" )
    confdbOptions['paths'].append( "-ExpressOutput" )
    confdbOptions['paths'].append( "-EventDisplayOutput" )
    confdbOptions['paths'].append( "-AlCaOutput" )
    confdbOptions['paths'].append( "-AlCaPPOutput" )
    confdbOptions['paths'].append( "-AlCaHIOutput" )
    confdbOptions['paths'].append( "-DQMOutput" )
    confdbOptions['paths'].append( "-HLTDQMOutput" )
    confdbOptions['paths'].append( "-HLTDQMResultsOutput" )
    confdbOptions['paths'].append( "-HLTMONOutput" )
    confdbOptions['paths'].append( "-NanoDSTOutput" )
    confdbOptions['paths'].append( "-OfflineOutput" )

    confdbOptions['psets'].append( "-maxEvents" )
    confdbOptions['psets'].append( "-options" )

    menu.getRawConfigurationFromDB(configuration.menuConfig, confdbSource, confdbOptions, configuration.doCff)

    # if running on MC, adapt the configuration accordingly
    if not configuration.runOnData:
      menu.fixForMC()

    # if required, remove the HLT prescales
    if configuration.menuUnprescale:
      menu.unprescale()

    # if requested, override the L1 menu from the GlobalTag (using the same connect as the GlobalTag itself)
    menu.overrideL1Menu(configuration)

else:
    if configuration.runOnline:
      # online we always run on data
      confdbSource =  "file:/tmp/InputCollection.root"
    else:
      # offline we can run on data, on mc, or on a user-specified dataset
      if configuration.menuDataset:
        # query DBS and extract the files for the specified dataset
        files = pipe("dbsql 'find file where dataset like %s'" % configuration.menuDataset)
        files = [ f for f in files.split('\n') if 'store' in f ][0:10]
        confdbSource = ','.join(files)
      elif configuration.runOnData:
        confdbSource = "/store/data/Run2010A/MinimumBias/RAW/v1/000/144/011/140DA3FD-AAB1-DF11-8932-001617E30E28.root"
      else:
        confdbSource =  "file:RelVal_DigiL1Raw_%s.root" % configuration.processType

    if not configuration.runOnData or configuration.menuL1.override:
      # remove any eventual L1 override from the table
      confdbOptions['essources'].append( "-Level1MenuOverride" )
      confdbOptions['esmodules'].append( "-l1GtTriggerMenuXml" )

    confdbOptions['services'].append( "-FUShmDQMOutputService" )
    confdbOptions['paths'].append( "-OfflineOutput" )

    menu.getRawConfigurationFromDB(configuration.menuConfig, confdbSource, confdbOptions, configuration.doCff)

    # if running on MC, adapt the configuration accordingly
    if not configuration.runOnData:
      menu.fixForMC()

    # if required, remove the HLT prescales
    if configuration.menuUnprescale:
      menu.unprescale()

    # manual override some Heavy Ion parameters
    if configuration.processType in ('HIon', ):
      menu.data += """
# HIon paths in smart prescalers
if 'hltPreHLTDQMSmart' in %(dict)s:
    %(process)shltPreHLTDQMSmart.throw = cms.bool( False )
if 'hltPreHLTMONSmart' in %(dict)s:
    %(process)shltPreHLTMONSmart.throw = cms.bool( False )
if 'hltPreExpressSmart' in %(dict)s:
    %(process)shltPreExpressSmart.throw = cms.bool( False )
if 'hltPreDQMSmart' in %(dict)s:
    %(process)shltPreDQMSmart.throw = cms.bool( False )
"""        

    # FIXME - find a better way to override the output modules
    menu.data = re.sub( 
      r'process\.hltOutput(\w+) *= *cms\.OutputModule\( *"ShmStreamConsumer" *,',
      r'process.hltOutput\1 = cms.OutputModule( "PoolOutputModule",\n    fileName = cms.untracked.string( "output\1.root" ),\n    fastCloning = cms.untracked.bool( False ),', 
      menu.data
    )

    menu.data += """
# set process name
%%(process)ssetName_('%(processName)s')

# add global options
%%(process)smaxEvents = cms.untracked.PSet(
    input = cms.untracked.int32( 100 )
)
%%(process)soptions = cms.untracked.PSet(
    wantSummary = cms.untracked.bool( True )
)
""" % configuration.__dict__

    # if requested or necessary, override the GlobalTag and connection strings
    menu.overrideGlobalTag(configuration)

    # if requested, override the L1 menu from the GlobalTag (using the same connect as the GlobalTag itself)
    menu.overrideL1Menu(configuration)

    # the following is stolen from HLTrigger.Configuration.customL1THLT_Options
    menu.data += """
# adapt HLT modules to the correct process name
if 'hltTrigReport' in %(dict)s:
    %(process)shltTrigReport.HLTriggerResults       = cms.InputTag( 'TriggerResults','',%(process)sname_() )

if 'hltDQMHLTScalers' in %(dict)s:
    %(process)shltDQMHLTScalers.triggerResults      = cms.InputTag( 'TriggerResults','',%(process)sname_() )

if 'hltPreExpressSmart' in %(dict)s:
    %(process)shltPreExpressSmart.TriggerResultsTag = cms.InputTag( 'TriggerResults','',%(process)sname_() )

if 'hltPreHLTMONSmart' in %(dict)s:
    %(process)shltPreHLTMONSmart.TriggerResultsTag  = cms.InputTag( 'TriggerResults','',%(process)sname_() )

if 'hltPreDQMSmart' in %(dict)s:
    %(process)shltPreDQMSmart.TriggerResultsTag     = cms.InputTag( 'TriggerResults','',%(process)sname_() )

if 'hltDQML1SeedLogicScalers' in %(dict)s:
    %(process)shltDQML1SeedLogicScalers.processname = %(process)sname_()

%(process)sMessageLogger.categories.append('TriggerSummaryProducerAOD')
%(process)sMessageLogger.categories.append('L1GtTrigReport')
%(process)sMessageLogger.categories.append('HLTrigReport')
"""


# dump the final configuration
print menu.data % menu.labels

