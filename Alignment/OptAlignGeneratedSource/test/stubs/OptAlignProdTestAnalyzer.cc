// -*- C++ -*-
//
// Package:    AlignmentTools/OptAlignGeneratedSource/test/stubs
// Class:      OptAlignProdTestAnalyzer.cc
// 
/**\class OptAlignProdTestAnalyzer OptAlignProdTestAnalyzer.cc AlignmentTools/OptAlignGeneratedSource/test/stubs/OptAlignProdTestAnalyzer.cc

 Description: test access to the OptAlignments via OptAlignGeneratedSource
    This also should demonstrate access to a geometry via the XMLIdealGeometryESSource
    for use in THE COCOA analyzer.

 Implementation:
     Iterate over retrieved alignments.
*/
//
// Original Author:  Mike Case
//         Created:  Mon Jan 17 11:47:40 CET 2006
// $Id$
//
//

#include <stdexcept>
#include <string>
#include <iostream>
#include <map>
#include "FWCore/Framework/interface/EDAnalyzer.h"
#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/ESHandle.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/Framework/interface/EventSetup.h"
#include "FWCore/Framework/interface/ESHandle.h"
#include "FWCore/Framework/interface/Handle.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include "CondFormats/OptAlignObjects/interface/OpticalAlignments.h"
#include "CondFormats/DataRecord/interface/OpticalAlignmentsRcd.h"

#include "DetectorDescription/Core/interface/DDExpandedView.h"

#include "Geometry/Records/interface/IdealGeometryRecord.h"

#include "CLHEP/Matrix/Matrix.h"

using namespace std;

  class OptAlignProdTestAnalyzer : public edm::EDAnalyzer
  {
  public:
    explicit  OptAlignProdTestAnalyzer(edm::ParameterSet const& p) 
    { }
    explicit  OptAlignProdTestAnalyzer(int i) 
    { }
    virtual ~ OptAlignProdTestAnalyzer() { }

    virtual void beginJob(const edm::EventSetup& c);
    virtual void analyze(const edm::Event& e, const edm::EventSetup& c);
    // see note on endJob() at the bottom of the file.
    // virtual void endJob() ;
  private:
  };

void OptAlignProdTestAnalyzer::beginJob ( const edm::EventSetup& c ) {
  // STEP ONE:  I'm not sure, but I believe the initial COCOA 
  // objects will be built from a DetectorDescription geometry
  // description.  It is STILL not clear to me if this is the 
  // "standard, Ideal CMS" geometry or some special files for
  // COCOA.
  // IMPORTANT: for analysis jobs this would still be in analyze
  // only for the COCOA analysis would this be accessed via
  // beginJob.
  
  edm::ESHandle<DDCompactView> cpv;
  c.get<IdealGeometryRecord>().get(cpv);

  std::cout << cpv->root() << std::endl;

  // example of traversing the whole optical alignment geometry.
  // more can be done here, for example, at each node, one could
  // request any specpars as variables and use them in constructing
  // COCOA objects.
  DDExpandedView expv( (*cpv) );

  std::cout << "about to traverse the expanded view" << std::endl;
  while ( expv.next() ) {
    std::cout << expv.geoHistory() << std::cout << endl;
  }
} // end of ::beginJob

void OptAlignProdTestAnalyzer::analyze(const edm::Event& e, const edm::EventSetup& context)
{
  using namespace edm::eventsetup;
  std::cout <<" I AM IN RUN NUMBER "<<e.id().run() <<std::endl;
  std::cout <<" ---EVENT NUMBER "<<e.id().event() <<std::endl;
  
  // If one wanted to get the "initial" version from an existing
  // alignment PoolDBESSource they would do the following:
  //     edm::ESHandle<OpticalAlignments> oa;
  //     context.get<OpticalAlignmentsRcd>().get(oa);
  //     //  just iterate over all of them...
  // to see how to iterate over the OpticalAlignments, please
  // refer to the << operator of OpticalAlignments, OpticalAlignInfo
  // and OpticalAlignParam.
  //     const OpticalAlignments* myoa=oa.product();
  
  // This retrieves the OpticalAlignments via the event data.
  // for each event, a new set of alignments comes in to the 
  // framework.
  edm::Handle<OpticalAlignments> oaHandle;
  e.getByLabel("OptAlignGeneratedSource", oaHandle); 
  
  std::cout << *oaHandle << std::endl;

  //============== COCOA WORK!
  //  Each set of optical alignment corrections can be used
  //  in whatever type of analysis COCOA does. 
  //==============
  
} //end of ::analyze()

// one could use ::endJob() to write out the OpticalAlignments
// generated by the analysis. Example code is in
// CondFormats/Alignment/test/testOptAlignWriter.cc


DEFINE_FWK_MODULE(OptAlignProdTestAnalyzer)
