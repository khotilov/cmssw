<?xml version="1.0"  standalone="no" ?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 1400 700" xmlns="http://www.w3.org/2000/svg" onload="init(evt)" onresize="myMapApp.resetFactors();" zoomAndPan="disable">
<script type="text/ecmascript"> <![CDATA[
  //section to contain script code
  //global variable to hold reference to svgdocument element
  var svgdoc;
  var myMapApp = new mapApp();
  var myMainMap;
  var myRefMapDragger;
  function init(evt) {
     //get the svgdocument reference
     svgdoc = evt.target.ownerDocument;
     
     myMapApp.resetFactors();
     myMainMap = new map("mainMap",3000,100,1000,0.6);
     //set constraints to draggable rect in reference map
     myRefMapDragger = new dragObj("dragRectForRefMap",0,200,510,610,"ul");
     
     //colorRegion();
  }
  function showData(evt) {
        var xlinkns = "http://www.w3.org/1999/xlink"; 
	var myPoly = evt.target;
	var myDynamicTrackerText = svgdoc.getElementById("TrackerText");
        var myDynamicTrackerText1 = svgdoc.getElementById("TrackerText1");
        var myDynamicTrackerMessage = svgdoc.getElementById("TrackerMessage");
        var myTrackerPlot = svgdoc.getElementById("plot");
        if (evt.type == "mouseover") {
                var myTracker = myPoly.getAttribute("POS");
                var myTracker1 = "  value="+myPoly.getAttribute("value");
                var myMessage = myPoly.getAttribute("MESSAGE");
                myTracker1 = myTracker1+" count="+myPoly.getAttribute("count");
                myDynamicTrackerText.firstChild.setData(myTracker);
                myDynamicTrackerText1.firstChild.setData(myTracker1);
                myDynamicTrackerMessage.firstChild.setData(myMessage);
        }

	if (evt.type == "mouseout") {
		myDynamicTrackerText.firstChild.setData("-");				
	}
	if (evt.type == "click") {
		myDynamicTrackerText.firstChild.setData("-");	
		var moduleId = myPoly.getAttribute("detid");
                var url_serv = "http://lxplus057.cern.ch:1972/urn:xdaq-application:lid=15/Request?";
                var queryString = "RequestID=PlotTkMapHistogram";
		queryString+= "&ModId=" + moduleId;
                var url1 = url_serv  + queryString;
//                var filename=moduleId+".jpg";
//                myTrackerPlot.setAttributeNS( xlinkns, "xlink:href", filename ) 
                myTrackerPlot.setAttributeNS( xlinkns, "xlink:href", url1);
                
                pausecomp(5000);
                queryString = "RequestID=UpdatePlot&t="+moduleId;
                var url2 = url_serv  + queryString;

                myTrackerPlot.setAttributeNS( xlinkns, "xlink:href", url2);  
              
		var myTracker = myPoly.getAttribute("POS");
                myTracker = myTracker+"  value="+myPoly.getAttribute("value");
	        myTracker = myTracker+"  count="+myPoly.getAttribute("count");
		myDynamicTrackerText.firstChild.setData(myTracker);
	}
  }
  function colorRegion() {
	var myGroup = svgdoc.getElementById("tracker");
	var children = myGroup.childNodes;
	var myModule;					
	//loop over all children
	//for (var i = 0; i < children.length;i++) {
	for (var i = 0; i < 10000;i++) {
	//check if it is a path-element
	 if (children.item(i).nodeName == "polygon") {
	   myModule = children.item(i).getAttribute("MODULE");
		switch (myModule) {
		   case "stereo":
			myColor = "blue";
			break;
		   case "nostereo":
			myColor = "rgb(255,255,0)";
			break;
		   default:
			myColor = "red";
		}
	   children.item(i).setAttribute("fill",myColor);
	 }
        }			
  }
  //holds data on map
  function map(mapName,origWidth,minZoom,maxZoom,zoomFact) {
	var mapSVG = svgdoc.getElementById(mapName);
	this.mapName = mapName;
	this.origWidth = origWidth;
	this.minZoom = minZoom;
	this.maxZoom = maxZoom;
	this.zoomFact = zoomFact;
	this.pixXOffset = parseFloat(mapSVG.getAttributeNS(null,"x"));
	this.pixYOffset = parseFloat(mapSVG.getAttributeNS(null,"y"));
	viewBoxArray = mapSVG.getAttributeNS(null,"viewBox").split(" ");
	this.curxOrig = parseFloat(viewBoxArray[0]);
	this.curyOrig = parseFloat(viewBoxArray[1]);
	this.curWidth = parseFloat(viewBoxArray[2]);
	this.curHeight = parseFloat(viewBoxArray[3]);
	this.pixWidth = parseFloat(mapSVG.getAttributeNS(null,"width"));
	this.pixHeight = parseFloat(mapSVG.getAttributeNS(null,"height"));
	this.pixXOrig = parseFloat(mapSVG.getAttributeNS(null,"x"));
	this.pixYOrig = parseFloat(mapSVG.getAttributeNS(null,"y"));
	this.pixSize = this.curWidth / this.pixWidth;
	this.zoomVal = this.origWidth / this.curWidth * 100;
  }
  map.prototype.newViewBox = function(refRectId,refMapId) {
	var myRefRect = svgdoc.getElementById(refRectId);
	var myRefMapSVG = svgdoc.getElementById(refMapId);
	var viewBoxArray = myRefMapSVG.getAttributeNS(null,"viewBox").split(" ");
	var refPixSize = viewBoxArray[2] / myRefMapSVG.getAttributeNS(null,"width");
	this.curxOrig = parseFloat(viewBoxArray[0]) + (myRefRect.getAttributeNS(null,"x") - myRefMapSVG.getAttributeNS(null,"x")) * refPixSize;
	this.curyOrig = parseFloat(viewBoxArray[1]) + (myRefRect.getAttributeNS(null,"y") - myRefMapSVG.getAttributeNS(null,"y")) * refPixSize;
	this.curWidth = myRefRect.getAttributeNS(null,"width") * refPixSize;
	this.curHeight = myRefRect.getAttributeNS(null,"height") * refPixSize;
	var myViewBoxString = this.curxOrig + " " + this.curyOrig + " " + this.curWidth + " " + this.curHeight;
	this.pixSize = this.curWidth / this.pixWidth;
	this.zoomVal = this.origWidth / this.curWidth * 100;
	svgdoc.getElementById(this.mapName).setAttributeNS(null,"viewBox",myViewBoxString);
  }
  //holds data on window size
  function mapApp() {
  }		
  //calculate ratio and offset values of app window
  mapApp.prototype.resetFactors = function() {
	var svgroot = svgdoc.documentElement;
	if (!svgroot.getScreenCTM) {
		//case for ASV3 and Corel
		var viewBoxArray = svgroot.getAttributeNS(null,"viewBox").split(" ");
		var myRatio = viewBoxArray[2]/viewBoxArray[3];
		if ((window.innerWidth/window.innerHeight) > myRatio) { //case window is more wide than myRatio
			this.scaleFactor = viewBoxArray[3] / window.innerHeight;
		}
		else { //case window is more tall than myRatio
			this.scaleFactor = viewBoxArray[2] / window.innerWidth;		
		}
		this.offsetX = (window.innerWidth - viewBoxArray[2] * 1 / this.scaleFactor) / 2;
		this.offsetY = (window.innerHeight - viewBoxArray[3] * 1 / this.scaleFactor) / 2;
		}
  }
   mapApp.prototype.calcCoord = function(coordx,coordy) {
	var svgroot = svgdoc.documentElement;
	var coords = new Array();
	if (!svgroot.getScreenCTM) {
	  //case ASV3 a. Corel
	  coords["x"] = (coordx  - this.offsetX) * this.scaleFactor;
	  coords["y"] = (coordy - this.offsetY) * this.scaleFactor;
	}
	else {
	  matrix=svgroot.getScreenCTM();
	  coords["x"]= matrix.inverse().a*coordx+matrix.inverse().c*coordy+matrix.inverse().e;
	  coords["y"]= matrix.inverse().b*coordx+matrix.inverse().d*coordy+matrix.inverse().f;
	 }
	return coords;
  }		
  
  //make an element draggable with constraints
  function dragObj(dragId,constrXmin,constrXmax,constrYmin,constrYmax,refPoint) {
	this.dragId = dragId;
	this.constrXmin = constrXmin;
	this.constrXmax = constrXmax;
	this.constrYmin = constrYmin;
	this.constrYmax = constrYmax;
	this.refPoint = refPoint;
	this.status = "false";
  }
  dragObj.prototype.drag = function(evt) {
        //works only for rect and use-elements
        var myDragElement = evt.target;
	if (evt.type == "mousedown") {
		var coords = myMapApp.calcCoord(evt.clientX,evt.clientY);
		this.curX = coords["x"];
		this.curY = coords["y"];
		this.status = "true";
	}
	if (evt.type == "mousemove" && this.status == "true") {
		var coords = myMapApp.calcCoord(evt.clientX,evt.clientY);
		var newEvtX = coords["x"];
		var newEvtY = coords["y"];
		var bBox = myDragElement.getBBox();
		if (this.refPoint == "ul") {
		  var toMoveX = bBox.x + newEvtX - this.curX;
		  var toMoveY = bBox.y + newEvtY - this.curY;
		}
		else {
		  //refPoint = center
		  var toMoveX = bBox.x + bBox.width / 2 + newEvtX - this.curX;
		  var toMoveY = bBox.y + bBox.height / 2 + newEvtY - this.curY;
		}
		if ((bBox.x + newEvtX - this.curX) < this.constrXmin) {
		  if(this.refPoint == "ul") {
		     toMoveX = this.constrXmin;
		  }
		  else {
		   toMoveX = this.constrXmin + bBox.width / 2;
		  }
	        }
		if ((bBox.x + newEvtX - this.curX + bBox.width) > this.constrXmax) {
			if(this.refPoint == "ul") {
		  	  toMoveX = this.constrXmax - bBox.width;
			}
			else {
		  	  toMoveX = this.constrXmax - bBox.width / 2;
			}					
		}
		if ((bBox.y + newEvtY - this.curY) < this.constrYmin) {
	 		if(this.refPoint == "ul") {
		  	 toMoveY = this.constrYmin;
			}
			else {
		  	 toMoveY = this.constrYmin + bBox.height / 2;
			}
		}
		if ((bBox.y + bBox.height + newEvtY - this.curY) > this.constrYmax) {
			if(this.refPoint == "ul") {
		  	 toMoveY = this.constrYmax - bBox.height;
			}
			else {
		 	 toMoveY = this.constrYmax - bBox.height / 2;
			}					
		}
		myDragElement.setAttributeNS(null,"x",toMoveX);
		myDragElement.setAttributeNS(null,"y",toMoveY);
		this.curX = newEvtX;
		this.curY = newEvtY;
	}
	if (evt.type == "mouseup" || evt.type == "mouseout") {
		this.status = "false";
	}			
  }
  dragObj.prototype.zoom = function(inOrOut) {
	var myDragElement = svgdoc.getElementById(this.dragId);
	var myOldX = myDragElement.getAttributeNS(null,"x");
	var myOldY = myDragElement.getAttributeNS(null,"y");
	var myOldWidth = myDragElement.getAttributeNS(null,"width");
	var myOldHeight = myDragElement.getAttributeNS(null,"height");
	switch (inOrOut) {
	   case "in":
		var myNewX = parseFloat(myOldX) + myOldWidth / 2 - (myOldWidth * myMainMap.zoomFact * 0.5);
		var myNewY = parseFloat(myOldY) + myOldHeight / 2 - (myOldHeight * myMainMap.zoomFact * 0.5);
		var myNewWidth = myOldWidth * myMainMap.zoomFact;
		var myNewHeight = myOldHeight * myMainMap.zoomFact;
		break;
	   case "out":
		var myNewX = parseFloat(myOldX) + myOldWidth / 2 - (myOldWidth * (1 + myMainMap.zoomFact) * 0.5);
		var myNewY = parseFloat(myOldY) + myOldHeight / 2 - (myOldHeight * (1 + myMainMap.zoomFact) * 0.5);
		var myNewWidth = myOldWidth * (1 + myMainMap.zoomFact);
		var myNewHeight = myOldHeight * (1 + myMainMap.zoomFact);
		break;
	   default:
		var myNewX = this.constrXmin;
		var myNewY = this.constrYmin;
		var myNewWidth = this.constrXmax - this.constrXmin;
		var myNewHeight = this.constrYmax - this.constrYmin;
		break;
	}
	if (myNewWidth > (this.constrXmax - this.constrXmin)) {
		myNewWidth = this.constrXmax - this.constrXmin;
	}
	if (myNewHeight > (this.constrYmax - this.constrYmin)) {
		myNewHeight = this.constrYmax - this.constrYmin;
	}
	if (myNewX < this.constrXmin) {
		myNewX = this.constrXmin;
	}
	if (myNewY < this.constrYmin) {
		myNewY = this.constrYmin;
	}
	if ((myNewX + myNewWidth) > this.constrXmax) {
		myNewX = this.constrXmax - myNewWidth;
	}
	if ((myNewY + myNewHeight) > this.constrYmax) {
		myNewY = this.constrYmax - myNewHeight;
	}
	myDragElement.setAttributeNS(null,"x",myNewX);
	myDragElement.setAttributeNS(null,"y",myNewY);
	myDragElement.setAttributeNS(null,"width",myNewWidth);
	myDragElement.setAttributeNS(null,"height",myNewHeight);
	myMainMap.newViewBox(this.dragId,"referenceMap");
  }
  //magnifier glass mouse-over effects
  function magnify(evt,scaleFact,inOrOut) {
	if (inOrOut == "in") {
	   if (myMainMap.zoomVal < myMainMap.maxZoom) {
	      scaleObject(evt,scaleFact);
	   }
	   else {
	   }
	}
	if (inOrOut == "out") {
           if (myMainMap.zoomVal > myMainMap.minZoom) {
	       scaleObject(evt,scaleFact);
	   }
	   else {
	   }		
	}
	if (inOrOut == "full") {
	   if (myMainMap.zoomVal > myMainMap.minZoom) {
	      scaleObject(evt,scaleFact);
	   }
	   else {			
	   }		
	}
	if (scaleFact == 1) {	
	   scaleObject(evt,scaleFact);
        }
  }
  //scale an object
  function scaleObject(evt,factor) {
  //reference to the currently selected object
        var element = evt.currentTarget;
	var myX = element.getAttributeNS(null,"x");
	var myY = element.getAttributeNS(null,"y");
        var newtransform = "scale(" + factor + ") translate(" + (myX * 1 / factor - myX) + " " + (myY * 1 / factor - myY) +")";
        element.setAttributeNS(null,'transform', newtransform);
  }
  function zoomIt(inOrOut) {
	if (inOrOut == "in") {
	   if (myMainMap.zoomVal < myMainMap.maxZoom) {
              myRefMapDragger.zoom("in");
	   }
	   else {
	   }
	}
	if (inOrOut == "out") {
	   if (myMainMap.zoomVal > myMainMap.minZoom) {
	       myRefMapDragger.zoom("out");
	   }
	   else {			
	   }		
	}
	if (inOrOut == "full") {
	     if (myMainMap.zoomVal > myMainMap.minZoom) {
	        myRefMapDragger.zoom("full");				
	     }
	     else {	
	     }		
	}
  }

function pausecomp(millis)
{
var inizio = new Date();
var inizioint=inizio.getTime();
var intervallo = 0;
while(intervallo<millis){
var fine = new Date();
var fineint=fine.getTime();
 intervallo = fineint-inizioint;
}
return;
}

]]> </script>
<defs>
<!-- section for CSS stylesheet definitions -->
<style type="text/css"><![CDATA[  
      .normalText {font-size:20;fill:black;font-weight:bold;}
      .dragRect {fill:darkcyan;stroke:none;opacity:0.4;}
  ]]></style>
   <symbol id="magnifyer" overflow="visible" style="fill:white;stroke:darkcyan;stroke-width:2;" >
    <circle r="12" />
  </symbol>
  <symbol id="magnifyerZoomOut" overflow="visible" style="fill:white;stroke:darkcyan;stroke-width:2;" >
    <use xlink:href="#magnifyer"/>
    <line x1="-6" y1="0" x2="6" y2="0" style="stroke:darkcyan;stroke-width:2;"/>
  </symbol>
  <symbol id="magnifyerZoomIn" overflow="visible">
    <use xlink:href="#magnifyer"/>
    <line x1="-6" y1="0" x2="6" y2="0" style="stroke:darkcyan;stroke-width:2;"/>
    <line x1="0" y1="-6" x2="0" y2="6" style="stroke:darkcyan;stroke-width:2;"/>
  </symbol>
  <symbol id="magnifyerFull" overflow="visible">
    <use xlink:href="#magnifyer"/>
    <line x1="-2" y1="0" x2="4" y2="0" style="stroke:darkcyan;stroke-width:2;"/>
    <line x1="-2" y1="-6" x2="-4" y2="6" style="stroke:darkcyan;stroke-width:2;"/>
    <line x1="-2" y1="-6" x2="5" y2="-6" style="stroke:darkcyan;stroke-width:2;"/>
  </symbol>
</defs>
<svg id="referenceMap" x="0" y="510" viewBox="0 0 3000 1600" width="180" height="100" pointer-events="none">
	<use xlink:href="#tracker" />
</svg>
<rect id="dragRectForRefMap" class="dragRect" x="0" y="510" width="180" height="100" onmousedown="myRefMapDragger.drag(evt)" onmousemove="myRefMapDragger.drag(evt)" onmouseup="myRefMapDragger.drag(evt);myMainMap.newViewBox('dragRectForRefMap','referenceMap')" />
 
  <g id="navigatorElements" class="normalText">       	  
	<text x="220" y="530">Zoom</text>	
        <!--istanziare il simbolo-->
	<use  id="zoomOut" x="230" y="560" xlink:href="#magnifyerZoomOut" onclick="zoomIt('out');"  onmouseover="magnify(evt,1.2,'out');" onmouseout="magnify(evt,1,'out');" />
	<use  id="zoomIn" x="270" y="560" xlink:href="#magnifyerZoomIn" onclick="zoomIt('in');"  onmouseover="magnify(evt,1.2,'in');" onmouseout="magnify(evt,1,'in');"/>
	<use  id="zoomFull" x="310" y="560" xlink:href="#magnifyerFull" onclick="zoomIt('full');"  onmouseover="magnify(evt,1.2,'full');" onmouseout="magnify(evt,1,'full');"/>
        <text id="TrackerText" x="350" y="530"> - </text>
        <text id="TrackerText1" x="350" y="565"> - </text>
        <text id="TrackerMessage" x="350" y="600"> - </text>
  </g>
<image id="plot" x="900" y="10" width="420" height="400" /> 
<svg id="mainMap" x="0" y="0" viewBox="0 0 3000 1600" width="900" height="500">
<rect fill="lightblue" stroke="none" x="0" y="0" width="3000" height="1600" /> 
<g id="tracker" transform="translate(10,1500) rotate(270)" style="fill:none;stroke:black;stroke-width:0;"> 
