// $Id: DQMEventStore.icc,v 1.1.4.2 2011/03/07 11:33:04 mommsen Exp $
/// @file: DQMEventStore.icc

#include "TROOT.h"
#include "TTimeStamp.h"

#include "toolbox/task/WorkLoopFactory.h"

#include "EventFilter/StorageManager/interface/DQMEventMonitorCollection.h"
#include "EventFilter/StorageManager/interface/DQMEventStore.h"
#include "EventFilter/StorageManager/interface/I2OChain.h"
#include "EventFilter/StorageManager/interface/QueueID.h"
#include "EventFilter/StorageManager/interface/StatisticsReporter.h"
#include "EventFilter/StorageManager/interface/Utils.h"


namespace stor {
    
  template<class EventType, class ConnectionType, class StateMachineType>  
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  DQMEventStore
  (
    xdaq::ApplicationDescriptor* appDescriptor,
    DQMEventQueueCollectionPtr dqmEventQueueCollection,
    DQMEventMonitorCollection& dqmEventMonColl,
    ConnectionType* connectionType,
    size_t (ConnectionType::*getExpectedUpdatesCount)() const,
    StateMachineType* stateMachineType,
    void (StateMachineType::*moveToFailedState)(xcept::Exception&)
  ) :
  appDescriptor_(appDescriptor),
  dqmEventQueueCollection_(dqmEventQueueCollection),
  dqmEventMonColl_(dqmEventMonColl),
  connectionType_(connectionType),
  getExpectedUpdatesCount_(getExpectedUpdatesCount),
  stateMachineType_(stateMachineType),
  moveToFailedState_(moveToFailedState),
  processCompletedTopLevelFolders_(false)
  {
    gROOT->SetBatch(kTRUE);
    startWorkLoop();
  }

  template<class EventType, class ConnectionType, class StateMachineType>  
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  ~DQMEventStore()
  {
    clear();
  }

  template<class EventType, class ConnectionType, class StateMachineType>  
  void
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  clear()
  {
    boost::mutex::scoped_lock sl(storeMutex_);
    store_.clear();
    processCompletedTopLevelFolders_ = false;
    tempEventArea_.clear();
  }
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  void
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  purge()
  {
    processCompletedTopLevelFolders_ = false;
    while ( handleNextCompletedTopLevelFolder() ) {}
    boost::mutex::scoped_lock sl(storeMutex_);
    store_.clear();
  }
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  void
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  setParameters(DQMProcessingParams const& dqmParams)
  {
    clear();
    dqmParams_ = dqmParams;
    processCompletedTopLevelFolders_ = true;
    completedFolderWL_->submit(completedFolderAction_);
  }
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  void
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  addDQMEvent(EventType const& dqmEvent)
  {
    if ( dqmParams_.collateDQM_ )
      addDQMEventToStore(dqmEvent);
    else
      addDQMEventToReadyToServe(dqmEvent);
  }
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  void
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  addDQMEventToStore(EventType const& dqmEvent)
  {
    const DQMKey newKey = dqmEvent.dqmKey();
    
    boost::mutex::scoped_lock sl(storeMutex_);
    DQMTopLevelFolderMap::iterator pos = store_.lower_bound(newKey);
    
    if(pos == store_.end() || (store_.key_comp()(newKey, pos->first)))
    {
      // Use pos as a hint to insert a new record, so it can avoid another lookup
      DQMTopLevelFolderPtr topLevelFolder( new DQMTopLevelFolder(
          newKey, dqmEvent.getDQMEventConsumerTags(),
          dqmParams_, dqmEventMonColl_, 
          (connectionType_->*getExpectedUpdatesCount_)()
        ));
      pos = store_.insert(pos, DQMTopLevelFolderMap::value_type(newKey, topLevelFolder));
    }
    pos->second->addDQMEvent(getDQMEventView(dqmEvent));
  }
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  void
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  addDQMEventToReadyToServe(EventType const& dqmEvent)
  {
    const DQMKey newKey = dqmEvent.dqmKey();

    DQMTopLevelFolderPtr topLevelFolder( new DQMTopLevelFolder(
        newKey, dqmEvent.getDQMEventConsumerTags(),
        dqmParams_, dqmEventMonColl_, 1));
    topLevelFolder->addDQMEvent(getDQMEventView(dqmEvent));

    boost::mutex::scoped_lock sl(storeMutex_);
    store_.insert(DQMTopLevelFolderMap::value_type(newKey, topLevelFolder));
  }
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  bool
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  getNextReadyTopLevelFolder(DQMTopLevelFolderPtr& topLevelFolder)
  {
    boost::mutex::scoped_lock sl(storeMutex_);
    utils::TimePoint_t now = utils::getCurrentTime();
    
    DQMTopLevelFolderMap::iterator it = store_.begin();
    DQMTopLevelFolderMap::const_iterator itEnd = store_.end();
    while ( it !=  itEnd && ! it->second->isReady(now) ) ++it;
    
    if ( it == itEnd ) return false;
    
    topLevelFolder = it->second;
    store_.erase(it);
    return true;
  }
  

  template<class EventType, class ConnectionType, class StateMachineType>  
  void
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  startWorkLoop()
  {
    try
    {
      std::string identifier = utils::getIdentifier(appDescriptor_);
    
      completedFolderWL_ = toolbox::task::getWorkLoopFactory()->
        getWorkLoop( identifier + "CompletedFolderWL", "waiting" );
    
      if ( ! completedFolderWL_->isActive() )
      {
        completedFolderWL_->activate();
      }

      completedFolderAction_ = 
          toolbox::task::bind(this,
            &DQMEventStore<EventType,ConnectionType,StateMachineType>::
            processCompletedTopLevelFolders,
            identifier + "CompletedFolder");
    }
    catch (xcept::Exception& e)
    {
      std::string msg = "Failed to start workloop 'CompletedFolderWL'.";
      XCEPT_RETHROW(exception::DQMEventProcessing, msg, e);
    }
  }
  
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  bool
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  processCompletedTopLevelFolders(toolbox::task::WorkLoop*)
  {
    std::string errorMsg = "Failed to send completed top level folders to consumers: ";

    ::sleep(5);

    try
    {
      while (
        processCompletedTopLevelFolders_ &&
        handleNextCompletedTopLevelFolder()
      ) {}
    }
    catch(xcept::Exception &e)
    {
      XCEPT_DECLARE_NESTED(exception::DQMEventProcessing,
        sentinelException, errorMsg, e );
      (stateMachineType_->*moveToFailedState_)(sentinelException);
    }
    catch(std::exception &e)
    {
      errorMsg += e.what();
      XCEPT_DECLARE(exception::DQMEventProcessing,
        sentinelException, errorMsg );
      (stateMachineType_->*moveToFailedState_)(sentinelException);
    }
    catch(...)
    {
      errorMsg += "Unknown exception";
      XCEPT_DECLARE(exception::DQMEventProcessing,
        sentinelException, errorMsg );
      (stateMachineType_->*moveToFailedState_)(sentinelException);
    }
    
    return processCompletedTopLevelFolders_;
  }
  
  
  template<class EventType, class ConnectionType, class StateMachineType>  
  bool
  DQMEventStore<EventType,ConnectionType,StateMachineType>::
  handleNextCompletedTopLevelFolder()
  {
    DQMTopLevelFolderPtr topLevelFolder;
    if ( getNextReadyTopLevelFolder(topLevelFolder) )
    {
      DQMTopLevelFolder::Record record;
      topLevelFolder->getRecord(record);
      dqmEventQueueCollection_->addEvent(record);
      return true;
    }

    return false;
  }

} // namespace stor


/// emacs configuration
/// Local Variables: -
/// mode: c++ -
/// c-basic-offset: 2 -
/// indent-tabs-mode: nil -
/// End: -
