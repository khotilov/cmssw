<! Template File - Modify as required.>
<! Use as an index to other html documents>
<! References to local pages should be relative to this directory>
<! This makes it easy for both users of the web project space and>
<! any others who might simply look at html files directly in the source code.>
<! e.g. href=page1.html or  href=mysubdir/page2.html >
<html>
<body>
<font size=+2><tt>CSCTFRawToDigi</tt></font> package performs unpacking
of raw CSC Track-Finder data. It is unlikely that you need it,
unless you are explicitly working with CSC TF data (for Data Quality
Monitoring or hardware validation purposes). So far no High Level Trigger
algorithms are known to use this kind of information.
<br>
<br>
The package is built around a set of core unpacking classes. Those are
accessors:
<tt>CSCSP_MEBlock</tt>, <tt>CSCSP_MBBlock</tt>, <tt>CSCSP_SPBlock</tt>,
<tt>CSCSPHeader</tt>, and <tt>CSCSPTrailer</tt>
and containers:
<tt>CSCSPRecord</tt>(also accessor), <tt>CSCSPEvent</tt>, and <tt>CSCTFEvent</tt>.
Accessors are essentially bit field classes, which directly map corresponding
raw data blocks. Containers hold clones of accessors and other containers
in a certain hierarchy. For references see
<a href="http://grid.ihepa.ufl.edu/~kkotov/LU-SP2DDU_Event_Record_Structure_4d1.pdf">hardware specification</a>.
<br>
<br>
The core unpacking classes can be easily compiled in a stand-alone executable.
An example can be found in
<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/CMSSW/EventFilter/CSCTFRawToDigi/test/test.cc?rev=1.1&cvsroot=CMSSW&content-type=text/vnd.viewcvs-markup">
test/test.cc</a>. If you want to use it you need to install CSC file reading
package in your local CMSSW installation (you don't need to compile it):

<br>
<b>cvs checkout -P IORawData/CSCCommissioning</b>
<br>
Go to EventFilter/CSCTFRawToDigi/test and comlipe the package:
<br>
<b>cd EventFilter/CSCTFRawToDigi/test</b>
<br>
<b>g++ -o test test.cc -I../../../</b>
<br>
After that you can run it on any CSCTF .raw data file:
<br>
<b>./test YOUR_RAW_FILE.raw</b>
<br>
<br>
The package is interfaced to CMSSW with help of 2 modules: <tt>CSCTFUnpacker</tt> and <tt>CSCTFPacker</tt>.
<br>
<br>
With parameter <i>producer</i> of <tt>edm::InputTag</tt> type the unpacking module can
be instructed to query <tt><a href="https://twiki.cern.ch/twiki/bin/view/CMS/WorkBookCMSSWFramework#ProcModel">edm::Event</a></tt>
for data buffers from particular producer (by default this is <tt>source:</tt>).
<br>
Every Sector Processor board (SP) of the CSC Track-Finder crate is connected to
1 of 12 sectors. The firmware on every board should be configured so, that board
reports which sector it is connected to. Unfortunately this is not a routine
configuration procedure on <a href="http://cms-emu-slicetest.web.cern.ch/cms-emu-slicetest/">CSC SliceTest</a>,
and our data lack this information. Fortunately every board reports
its slot ID in the Track-Finder crate. Based on the slot ID we can assign
every board to the particular sector off-line. It can be done with integral
array-parameter <i>slot2sector</i>. It has 22 entries (same as number of slots
in CSC Track-Finder crate) which can be set to either 0 or sector number (1&#151;12).
0 instructs module to use original sector number from data, while numbers from
1 to 12 override it with corresponding value. If you work with the <a href="http://cms-emu-slicetest.web.cern.ch/cms-emu-slicetest/">CSC SliceTest</a>,
data you probably need default settings of
<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/CMSSW/EventFilter/CSCTFRawToDigi/data/csctfunpacker.cfi?rev=1.4&cvsroot=CMSSW&content-type=text/vnd.viewcvs-markup">
data/csctfunpacker.cfi</a> while for raw data obtained in simulation (see below)
you need to set all values to 0. See
<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/CMSSW/EventFilter/CSCTFRawToDigi/test/writedigi.cfg?rev=1.1&cvsroot=CMSSW&content-type=text/vnd.viewcvs-markup">
test/writedigi.cfg</a> for example.
<br>
<br>
Supplementary <tt>CSCTFPacker</tt> module helps to generate fake raw data file
from CSC TF digi. It can also be instructed with <i>lctProducer</i> and
<i>trackProducer</i> <tt>edm::InputTag</tt>s to use digi from certain producers.
But besides of this it has to be configured as it would have to be done to the
real hardware. More likely you don't need here anything but setting default values
for two parameters: <i>zeroSuppression=true</i> and <i>nTBINs=7</i>.
Another parameter is <i>activeSectors</i>. It allows to "skim" data from any
particular sector(s). Any of its 12 bit may be set to 1 or 0 allowing
of denying data from corresponding sectors to be converted to raw buffers.
If you are validating SP boards you are likely to set only one of these bits.
Last two parameters control where the buffers go. <tt>outputFile</tt> sets a name
for fake raw data file (make it an empty string "" if yo don't need these files),
and <tt>putBufferToEvent</tt> specifies if <tt><a href="https://twiki.cern.ch/twiki/bin/view/CMS/WorkBookCMSSWFramework#ProcModel">edm::Event</a></tt>
will be populated with raw data buffers.
See
<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/CMSSW/EventFilter/CSCTFRawToDigi/test/writedigi.cfg?rev=1.1&cvsroot=CMSSW&content-type=text/vnd.viewcvs-markup">
test/writedigi.cfg</a> for example of usage.

</body>
</html>
