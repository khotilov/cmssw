#include "SimDataFormats/Track/interface/EmbdSimTrackContainer.h"
#include "SimDataFormats/Vertex/interface/EmbdSimVertexContainer.h"

#include "SimG4Core/Application/interface/RunManager.h"
#include "SimG4Core/Application/interface/PrimaryTransformer.h"
#include "SimG4Core/Application/interface/RunAction.h"
#include "SimG4Core/Application/interface/EventAction.h"
#include "SimG4Core/Application/interface/StackingAction.h"
#include "SimG4Core/Application/interface/TrackingAction.h"
#include "SimG4Core/Application/interface/SteppingAction.h"
#include "SimG4Core/Application/interface/G4SimEvent.h"

#include "SimG4Core/Geometry/interface/DDDWorld.h"
#include "SimG4Core/Generators/interface/Generator.h"
#include "SimG4Core/Physics/interface/PhysicsManager.h"

#include "G4StateManager.hh"
#include "G4ApplicationState.hh"
#include "G4RunManagerKernel.hh"
#include "G4UImanager.hh"

#include "G4EventManager.hh"
#include "G4Run.hh"
#include "G4Event.hh"

#include <iostream>
#include <memory>

using std::cout;
using std::endl;
using std::auto_ptr;

RunManager * RunManager::me = 0;
RunManager * RunManager::init(edm::ParameterSet const & p)
{
    if (me != 0) abort();
    me = new RunManager(p);
}

RunManager * RunManager::instance() 
{
    if (me==0) abort();
    return me;
}

RunManager::RunManager(edm::ParameterSet const & p) 
    : m_paramSet(p), m_generator(0), m_primaryTransformer(0), 
      m_managerInitialized(false), 
      m_geometryInitialized(true), m_physicsInitialized(true),
      m_runInitialized(false), m_runTerminated(false), m_runAborted(false),
      m_currentRun(0), m_currentEvent(0), m_simEvent(0), m_userRunAction(0)
{    
    m_context = new seal::Context;
    m_kernel = G4RunManagerKernel::GetRunManagerKernel();
    if (m_kernel==0) m_kernel = new G4RunManagerKernel();
    cout << " Run Manager c-ted " << endl;
}

RunManager::~RunManager() 
{ 
    if (m_kernel!=0) delete m_kernel; 
}

void RunManager::maybeInitializeManager(const edm::EventSetup & es)
{
    // If already initialized, skip
    if (m_managerInitialized) return;
 
    edm::ParameterSet geometrySet
          = m_paramSet.getParameter<edm::ParameterSet> ("Geometry");
    DDDWorld * world = new DDDWorld(geometrySet);
    // Create geometry manager which takes care of instantiating
    // the geometry, attaching sensitive detectors and all that
    // GeometryManager * geometryManager = new GeometryManager(m_context.get(),geometrySet);
 
    // Create generator
    edm::ParameterSet generatorSet
          = m_paramSet.getParameter<edm::ParameterSet> ("Generator");
    Generator * m_generator = new Generator(generatorSet);
    
//     seal::Handle<Generator> generator = GeneratorFactory::get()->create
//         (generatorSet.getParameter<std::string> ("type"), m_context, generatorSet);

    // Create physics manager which handles physics list, cuts
    edm::ParameterSet physicsSet
          = m_paramSet.getParameter<edm::ParameterSet> ("Physics");
    PhysicsManager * physicsManager = new PhysicsManager(m_context.get(),physicsSet);

    // Create primary transformer
//     edm::ParameterSet & transformerSet
//           = m_paramSet.getParameter<edm::ParameterSet> ("PrimaryTransformer");
//     seal::Handle<PrimaryTransformer> transform = PrimaryTransformerFactory::get->create
//          (transformSet.getParameter<std::string> ("type"), context, transformSet);

    // Dispatch geometry
//     geometryManager->finish();
     
    if (m_kernel->RunInitialization()) m_managerInitialized = true;
    initializeUserActions();
    initializeRun();
}

void RunManager::produce(const edm::EventSetup & es)
{
    std::cout << " inside RunManager produce " << std::endl;
    
    maybeInitializeManager(es);
 
//     static int i = 0;
//     m_currentEvent = generateEvent(i);
//     i++;

//     m_simEvent = new G4SimEvent;
//     m_simEvent->hepEvent(m_generator->genEvent());
//     m_simEvent->weight(m_generator->eventWeight());
//     m_simEvent->collisionPoint(HepLorentzVector(m_generator->genVertex().vect()/centimeter,
//                                                 m_generator->genVertex().t()/second));

//     if (m_currentEvent->GetNumberOfPrimaryVertex()==0)
//     {
//        cout << " RunManager::produce event " << i
//             << " with no G4PrimaryVertices " << endl;
//        cout << " Aborting run " << endl;
//        abortRun(false);
//     }
//     else
//         m_kernel->GetEventManager()->ProcessOneEvent(m_currentEvent);
     
//     cout << " saved : Event  " << i << " of weight " << m_simEvent->weight()
//          << " with " << m_simEvent->nTracks() << " tracks and " << m_simEvent->nVertices()
//          << " vertices, generated by " << m_simEvent->nGenParts() << " particles " << endl;
     
//     auto_ptr<edm::EmbdSimTrackContainer> p1(new edm::EmbdSimTrackContainer);
//     m_simEvent->load(*p1);
//     e.put(p1);
//     auto_ptr<edm::EmbdSimVertexContainer> p2(new edm::EmbdSimVertexContainer);
//     m_simEvent->load(*p2);
//     e.put(p2);

//     if (m_currentEvent!=0) delete m_currentEvent;
//     m_currentEvent = 0;
//     if (m_simEvent!=0) delete m_simEvent;
//     m_simEvent = 0;
}
 

G4Event * RunManager::generateEvent(int i)
{                       
    G4Event * e = new G4Event(i);
    const HepMC::GenEvent * g = m_generator->generateEvent();
    m_generator->HepMC2G4(g,e);
    return e;
}

void RunManager::abortEvent()
{
    m_currentEvent->SetEventAborted();
    m_kernel->GetEventManager()->AbortCurrentEvent();
}

void RunManager::initializeUserActions()
{
    m_userRunAction = new RunAction(m_paramSet.getParameter<edm::ParameterSet>("RunAction"));
    G4EventManager * eventManager = m_kernel->GetEventManager();
    eventManager->SetVerboseLevel(m_paramSet.getParameter<int>("G4EventManagerVerbosity"));
    if (m_generator!=0)
    {
        EventAction * userEventAction =
            new EventAction(m_paramSet.getParameter<edm::ParameterSet>("EventAction"));
        eventManager->SetUserAction(userEventAction);
        eventManager->SetUserAction(new TrackingAction(userEventAction,
		 m_paramSet.getParameter<edm::ParameterSet>("TrackingAction")));
        eventManager->SetUserAction(new SteppingAction
	         (m_paramSet.getParameter<edm::ParameterSet>("SteppingAction")));
        if (m_paramSet.getParameter<bool>("OverrideUserStackingAction"))
        {
            cout << " RunManager: user defined StackingAction overridden " << endl;
            eventManager->SetUserAction(new StackingAction);
            cout << " RunManager:SimG4Application StackingAction registered " << endl;
        }
    }
    else cout << " WARNING: No event generator; initialized only RunAction!" << endl;
}

void RunManager::initializeRun()
{
    m_runInitialized = false;
    if (m_currentRun==0) m_currentRun = new G4Run();
    m_currentRun->SetRunID(m_paramSet.getParameter<int>("RunNumber"));
    G4StateManager::GetStateManager()->SetNewState(G4State_GeomClosed);
    if (m_userRunAction!=0) m_userRunAction->BeginOfRunAction(m_currentRun);
    m_runAborted = false;
    m_runInitialized = true;
}
 
void RunManager::terminateRun()
{
    m_runTerminated = false;
    if (m_userRunAction!=0)
    {
        m_userRunAction->EndOfRunAction(m_currentRun);
        delete m_userRunAction; m_userRunAction = 0;
    }
    if (m_currentRun!=0) { delete m_currentRun; m_currentRun = 0; }
    if (m_kernel!=0) m_kernel->RunTermination();
    m_runInitialized = false;
    m_runTerminated = true;
}

void RunManager::abortRun(bool softAbort)
{
    m_runAborted = false;
    if (!softAbort) abortEvent();
    if (m_currentRun!=0) { delete m_currentRun; m_currentRun = 0; }
    m_runInitialized = false;
    m_runAborted = true;
}
