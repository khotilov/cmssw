#ifndef GEOMETRY_ECALGEOMETRYLOADER_ICC
#define GEOMETRY_ECALGEOMETRYLOADER_ICC 1

#include "CondFormats/Alignment/interface/AlignTransform.h"

#include "Geometry/CaloEventSetup/interface/CaloGeometryLoader.h"

#include "Geometry/CaloGeometry/interface/CaloCellGeometry.h"

#include "DetectorDescription/Core/interface/DDCompactView.h"
#include "DetectorDescription/Core/interface/DDCurrentNamespace.h"
#include "DetectorDescription/Core/interface/DDLogicalPart.h"
#include "DetectorDescription/Core/interface/DDSolid.h"
#include "DetectorDescription/Core/interface/DDMaterial.h"
#include "DetectorDescription/Core/interface/DDTransform.h"
#include "DetectorDescription/Core/interface/DDCompactView.h"
#include "DetectorDescription/Core/interface/DDExpandedView.h"
#include "DetectorDescription/Core/interface/DDNodes.h"
#include "DetectorDescription/Core/interface/DDSpecifics.h"
#include "DetectorDescription/Core/interface/DDName.h"
#include "DetectorDescription/Core/interface/DDScope.h"
#include "DetectorDescription/Core/interface/DDFilter.h"
#include "DetectorDescription/Core/interface/DDQuery.h"
#include "DetectorDescription/Core/interface/DDFilteredView.h"
#include "DetectorDescription/ExprAlgo/interface/ExprEvalSingleton.h"

#include "CLHEP/Units/SystemOfUnits.h"

#include <vector>

using namespace std;

template <class T>
CaloGeometryLoader<T>::CaloGeometryLoader() 
{
   m_filter.setCriteria( DDValue( "SensitiveDetector",
				  "EcalSensitiveDetector",
				  0                        ),
			 DDSpecificsFilter::equals,
			 DDSpecificsFilter::AND,
			 true,
			 true                               ) ;

   m_filter.setCriteria( DDValue( "ReadOutName",
				  T::hitString(),
				  0                  ),
			 DDSpecificsFilter::equals,
			 DDSpecificsFilter::AND,
			 true,
			 true                       ) ;
}

template <class T>
typename CaloGeometryLoader<T>::PtrType
CaloGeometryLoader<T>::load( const DDCompactView*  cpv        ,
			     const Alignments*     alignments ,
			     const AlignTransform* global       ) 
{
   PtrType geom ( new T ) ;

   makeGeometry( cpv,
		 dynamic_cast<T*>( geom.get() ),
		 alignments,
		 global ) ;

   return geom ;
}

template <class T>
void 
CaloGeometryLoader<T>::makeGeometry( const DDCompactView*  cpv        ,
				     T*                    geom       ,
				     const Alignments*     alignments ,
				     const AlignTransform* global       )
{
   DDFilteredView fv0 ( *cpv ) ;
   fv0.addFilter( m_filter ) ;

   fillNamedParams( fv0, geom ) ;

   geom->allocateCorners( T::k_NumberOfCellsForCorners ) ;

   DDFilteredView fv( *cpv ) ;
   fv.addFilter( m_filter ) ;
 
   unsigned int counter ( 0 ) ;
   for( bool doSubDets = fv.firstChild(); doSubDets ; doSubDets = fv.nextSibling() )
   {
      ++counter ;
      const DDSolid& solid ( fv.logicalPart().solid() ) ;
      
      const ParmVec& parameters ( solid.parameters() ) ;

      DD3Vector x, y, z;
      fv.rotation().GetComponents( x, y, z ) ;
      const HepRep3x3 temp( x.X(), y.X(), z.X(),
			    x.Y(), y.Y(), z.Y(),
			    x.Z(), y.Z(), z.Z() );
      const HepRotation hr ( temp );
      const Hep3Vector h3v( fv.translation().X(),
			    fv.translation().Y(),
			    fv.translation().Z()  ) ;
      const HepTransform3D ht3d ( hr,                        // only scale translation
				  CaloCellGeometry::k_ScaleFromDDDtoGeant*h3v ) ;    

      const DetId id ( getDetIdForDDDNode( fv ) ) ;

      const unsigned int which ( whichTransform( id ) ) ;

      assert( 0 == alignments ||
	      which < alignments->m_align.size() ) ;

      const AlignTransform* at ( 0 == alignments ? 0 :
				 &alignments->m_align[ which ] ) ;

      assert( 0 == at || ( whichTransform( DetId( at->rawId() ) ) ==
			   whichTransform( id ) ) ) ;

      const HepTransform3D atr ( 0 == at ? ht3d :
				 ( 0 == global ? at->transform()*ht3d :
				   global->transform()*at->transform()*ht3d ) ) ;
//				 HepTransform3D( at->rotation(), 
//						 at->translation()  )*ht3d ) ;

      fillGeom( geom, parameters, atr, id ) ;
   }

   assert( counter <= T::k_NumberOfCellsForCorners ) ;

   extraStuff( geom ) ;
}

template <class T>
unsigned int 
CaloGeometryLoader<T>::getDetIdForDDDNode( const DDFilteredView& fv )
{
  // perform some consistency checks
  // get the parents and grandparents of this node

  const DDGeoHistory& parents ( fv.geoHistory() ) ;
  const DDGeoHistory::size_type psize ( parents.size() ) ;

  EcalBaseNumber baseNumber ;
  baseNumber.setSize( psize ) ;

  for( unsigned int i=1 ; i<=psize ; ++i )
  {
     baseNumber.addLevel( parents[psize-i].logicalPart().name().name(),
			  parents[psize-i].copyno() ) ;
  }

  return m_scheme.getUnitID( baseNumber );  
}


#endif
