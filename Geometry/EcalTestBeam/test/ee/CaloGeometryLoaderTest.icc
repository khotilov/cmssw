#ifndef GEOMETRY_ECALGEOMETRYLOADER_ICC
#define GEOMETRY_ECALGEOMETRYLOADER_ICC 1

#include "CondFormats/Alignment/interface/AlignTransform.h"

#include "Geometry/EcalTestBeam/test/ee/CaloGeometryLoaderTest.h"

#include "Geometry/CaloGeometry/interface/CaloCellGeometry.h"

#include "Geometry/CaloGeometry/interface/CaloGenericDetId.h"

#include "DetectorDescription/Core/interface/DDCompactView.h"
#include "DetectorDescription/Core/interface/DDCurrentNamespace.h"
#include "DetectorDescription/Core/interface/DDLogicalPart.h"
#include "DetectorDescription/Core/interface/DDSolid.h"
#include "DetectorDescription/Core/interface/DDMaterial.h"
#include "DetectorDescription/Core/interface/DDTransform.h"
#include "DetectorDescription/Core/interface/DDCompactView.h"
#include "DetectorDescription/Core/interface/DDExpandedView.h"
#include "DetectorDescription/Core/interface/DDNodes.h"
#include "DetectorDescription/Core/interface/DDSpecifics.h"
#include "DetectorDescription/Core/interface/DDName.h"
#include "DetectorDescription/Core/interface/DDScope.h"
#include "DetectorDescription/Core/interface/DDFilter.h"
#include "DetectorDescription/Core/interface/DDQuery.h"
#include "DetectorDescription/Core/interface/DDFilteredView.h"
#include "DetectorDescription/ExprAlgo/interface/ExprEvalSingleton.h"

#include "CLHEP/Units/GlobalSystemOfUnits.h"
#include "CLHEP/Geometry/Plane3D.h"

#include <vector>

using namespace std;

template <class T>
const double 
CaloGeometryLoaderTest<T>::k_ScaleFromDDDtoGeant ( 0.1 ) ;

template <class T>
CaloGeometryLoaderTest<T>::CaloGeometryLoaderTest() 
{
   m_filter.setCriteria( DDValue( "Volume",
				  "EndcapSC",
//				  "EESCEnv1",
				  0                  ),
			 DDSpecificsFilter::equals    ) ;
//,
//			 DDSpecificsFilter::AND,
//			 true,
//			 true                       ) ;
}

template <class T>
typename CaloGeometryLoaderTest<T>::PtrType
CaloGeometryLoaderTest<T>::load( const DDCompactView*  cpv        ,
				 const Alignments*     alignments ,
				 const Alignments*     globals       ) 
{
   PtrType geom ( new T ) ;

   makeGeometry( cpv,
		 dynamic_cast<T*>( geom.get() ),
		 alignments,
		 globals ) ;

   return geom ;
}

template <class T>
void 
CaloGeometryLoaderTest<T>::makeGeometry( const DDCompactView*  cpv        ,
					 T*                    geom       ,
					 const Alignments*     alignments ,
					 const Alignments*     globals      )
{
   geom->allocateCorners( T::k_NumberOfCellsForCorners ) ;
   geom->allocatePar( T::k_NumberOfParametersPerShape*T::k_NumberOfShapes,
		      T::k_NumberOfParametersPerShape ) ;

   DDFilteredView fv ( *cpv ) ;
   fv.addFilter( m_filter ) ;

   unsigned int counter ( 0 ) ;
   for( bool doSubDets = fv.firstChild(); doSubDets ; doSubDets = fv.nextSibling() )
   {
      ++counter ;
      const DDSolid& solid ( fv.logicalPart().solid() ) ;
      
      const ParmVec& parameters ( solid.parameters() ) ;

      DD3Vector x, y, z;
      fv.rotation().GetComponents( x, y, z ) ;
      const CLHEP::HepRep3x3 temp( x.X(), y.X(), z.X(),
				   x.Y(), y.Y(), z.Y(),
			           x.Z(), y.Z(), z.Z() );
      const CLHEP::HepRotation hr ( temp );
      const CLHEP::Hep3Vector h3v ( fv.translation().X(),
		 		    fv.translation().Y(),
				    fv.translation().Z()  ) ;
      const HepGeom::Transform3D ht3d ( hr,          // only scale translation
	 	 		        k_ScaleFromDDDtoGeant*h3v ) ;    


      const unsigned int id ( getDetIdForDDDNode( fv ) ) ;

      myFillGeom( geom, parameters, ht3d, id ) ;
   }
}


template <class T>
void
CaloGeometryLoaderTest<T>::myFillGeom( T*                    geom ,
				   const ParmVec&          vv ,
				   const HepGeom::Transform3D&   tr ,
				   const unsigned int      id     )
{
   static const HepPoint3D PIVOT ( 13533.35, -000.02, 0 ) ;//-152.23 ) ;

   static const HepPoint3D IP    ( 0, 0, 0 ) ;//-152.23 ) ;
   static HepPoint3D AA0 ;
   static HepPoint3D BB0 ;
   static HepPoint3D CC0 ;
   static HepPoint3D DD0 ;
   static HepPoint3D EE0 ;
   static HepPoint3D FF0 ;
   static HepPoint3D GG0 ;
   static HepPoint3D HH0 ;

   std::vector<double> pv ;
   pv.reserve( vv.size() ) ;
   for( unsigned int i ( 0 ) ; i != vv.size() ; ++i )
   {
      const double factor ( 1==i || 2==i || 6==i || 10==i ? 1 : k_ScaleFromDDDtoGeant ) ;
      pv.push_back( factor*vv[i] ) ;
   }

   CaloCellGeometry::CornersVec corners ( geom->cornersMgr() ) ;
   corners.resize() ;

   TruncatedPyramid::createCorners( pv, tr, corners ) ;

   if( ( 160 == id ||
	 164 == id ||
	 134 == id ||
	 133 == id ||
	 153 == id ||
	 150 == id ||
	 130 == id    ) &&
       ( 0 < corners[0].x() &&
	 0 < corners[0].y() &&
	 0 < corners[0].z()    ) )
   {
/*      std::cout<<"\n *************** id = "<<id
	       <<"\n "<<corners[0]
	       <<"\n "<<corners[1]
	       <<"\n "<<corners[2]
	       <<"\n "<<corners[3]
	       <<"\n "<<corners[4]
	       <<"\n "<<corners[5]
	       <<"\n "<<corners[6]
	       <<"\n "<<corners[7]
	       <<std::endl ;*/

      if( 160 == id ) AA0 = HepPoint3D( corners[3].x(),
				       corners[3].y(),
				       corners[3].z() ) ;
      if( 164 == id ) BB0 = HepPoint3D( corners[2].x(),
				       corners[2].y(),
				       corners[2].z() ) ;
      if( 134 == id ) CC0 = HepPoint3D( corners[1].x(),
				       corners[1].y(),
				       corners[1].z() ) ;
      if( 130 == id ) DD0 = HepPoint3D( corners[0].x(),
				       corners[0].y(),
				       corners[0].z() ) ;
      if( 150 == id ) EE0 = HepPoint3D( corners[2].x(),
					corners[2].y(),
					corners[2].z() ) ;
      if( 153 == id ) FF0 = HepPoint3D( corners[2].x(),
					corners[2].y(),
					corners[2].z() ) ;
      if( 133 == id ) GG0 = HepPoint3D( corners[2].x(),
					corners[2].y(),
					corners[2].z() ) ;
      if( 130 == id ) HH0 = HepPoint3D( corners[2].x(),
					corners[2].y(),
					corners[2].z() ) ;
   }
   static bool done (false) ;
   if( 0.001 < AA0.mag() &&
       0.001 < BB0.mag() &&
       0.001 < CC0.mag() &&
       0.001 < DD0.mag() &&
       !done                  )
   {
      done = true ;

      const HepTransform3D H4ToBeamLine ( PIVOT + HepPoint3D( 0, 1, 0),
					  PIVOT + HepPoint3D( 0, 0, 1),
					  PIVOT + HepPoint3D( 1, 0, 0),
					  HepPoint3D( 0, -1, 0),
					  HepPoint3D( 1,  0, 0),
					  HepPoint3D( 0,  0, 1) ) ;

      std::cout<<"pivot to beamline="<<H4ToBeamLine*PIVOT<<std::endl ;
      std::cout<<"endcap to beamline="<<H4ToBeamLine*HepPoint3D(PIVOT.x()+316,0,50)
	       <<std::endl ;


      std::cout<<"\nA0 = "<<AA0
	       <<"\nB0 = "<<BB0
	       <<"\nC0 = "<<CC0
	       <<"\nD0 = "<<DD0
	       << std::endl ;

      const HepPoint3D A0 (AA0) ;
      const HepPoint3D B0 (BB0) ;
      const HepPoint3D C0 (CC0) ;
      const HepPoint3D D0 (DD0) ;

      const double angle ( (C0-B0).angle( A0-B0 ) ) ;

      static std::vector< HepPoint3D > extra ;
      extra.push_back( HepPoint3D(  13859.05,  005.79, -002.66 ) ) ;
      extra.push_back( HepPoint3D(  13860.98, -038.39, -002.11 ) ) ;
      extra.push_back( HepPoint3D(  13853.19, -039.25, -030.77 ) ) ;
      extra.push_back( HepPoint3D(  13851.23,  004.99, -031.39 ) ) ;



      static std::vector< HepPoint3D > sur ;
      sur.push_back( HepPoint3D( 13862.30,  20.68, 11.60 ) ) ;
      sur.push_back( HepPoint3D( 13865.69, -52.85, 12.64) ) ;
      sur.push_back( HepPoint3D( 13851.53, -54.27, -44.75 ) ) ;
      sur.push_back( HepPoint3D( 13848.21,  19.18, -45.89 ) ) ;

      sur.push_back( HepPoint3D( 13861.72,   28.62,   11.61 ) ) ;
      sur.push_back( HepPoint3D( 13866.88,  -44.81,   12.64 ) ) ;
      sur.push_back( HepPoint3D( 13852.76,  -46.56,  -44.73 ) ) ;
      sur.push_back( HepPoint3D( 13847.67,   26.79,  -45.88 ) ) ;
      sur.push_back( HepPoint3D( 13856.82,   63.41,   11.60 ) ) ;
      sur.push_back( HepPoint3D( 13869.76,   -9.06,   12.64 ) ) ;
      sur.push_back( HepPoint3D( 13855.90,  -12.31,  -44.73 ) ) ;
      sur.push_back( HepPoint3D( 13843.04,   60.08,  -45.89 ) ) ;
      sur.push_back( HepPoint3D( 13860.86,  -36.96,   11.60 ) ) ;
      sur.push_back( HepPoint3D( 13851.38, -109.96,   12.63 ) ) ;
      sur.push_back( HepPoint3D( 13837.21, -108.89,  -44.73 ) ) ;
      sur.push_back( HepPoint3D( 13846.73,  -35.98,  -45.88 ) ) ;
      sur.push_back( HepPoint3D( 13854.03,  -76.21,   11.60 ) ) ;
      sur.push_back( HepPoint3D( 13835.82, -147.53,   12.64 ) ) ;
      sur.push_back( HepPoint3D( 13821.88, -144.76,  -44.73 ) ) ;
      sur.push_back( HepPoint3D( 13840.13,  -73.54,  -45.88 ) ) ;
      sur.push_back( HepPoint3D( 13861.10,   35.48,   09.88 ) ) ;
      sur.push_back( HepPoint3D( 13867.78,  -37.82,   11.07 ) ) ;
      sur.push_back( HepPoint3D( 13853.42,  -40.01,  -46.22 ) ) ;
      sur.push_back( HepPoint3D( 13846.80,   33.21,  -47.52 ) ) ;
      sur.push_back( HepPoint3D( 13860.68,   35.23,   19.89 ) ) ;
      sur.push_back( HepPoint3D( 13867.35,  -38.08,   20.23 ) ) ;
      sur.push_back( HepPoint3D( 13854.67,  -39.43,  -37.48 ) ) ;
      sur.push_back( HepPoint3D( 13848.07,   33.79,  -37.92 ) ) ;
      sur.push_back( HepPoint3D( 13859.95,   34.97,   29.87 ) ) ;
      sur.push_back( HepPoint3D( 13866.62,  -38.34,   29.33 ) ) ;
      sur.push_back( HepPoint3D( 13855.61,  -38.88,  -28.76 ) ) ;
      sur.push_back( HepPoint3D( 13849.00,   34.34,  -28.32 ) ) ;
      sur.push_back( HepPoint3D( 13858.93,   34.41,   39.81 ) ) ;
      sur.push_back( HepPoint3D( 13865.65,  -38.90,   38.40 ) ) ;
      sur.push_back( HepPoint3D( 13856.34,  -38.58,  -19.97 ) ) ;
      sur.push_back( HepPoint3D( 13849.70,   34.65,  -18.68 ) ) ;
      sur.push_back( HepPoint3D( 13857.67,   33.69,   49.76 ) ) ;
      sur.push_back( HepPoint3D( 13864.43,  -39.60,   47.48 ) ) ;
      sur.push_back( HepPoint3D( 13856.81,  -38.43,  -11.13 ) ) ;
      sur.push_back( HepPoint3D( 13850.14,   34.78,   -8.95 ) ) ;

      double psumx  ( 0 ) ;
      double psumy  ( 0 ) ;
      double psumz  ( 0 ) ;
      double psumx2 ( 0 ) ;
      double psumy2 ( 0 ) ;
      double psumz2 ( 0 ) ;

      double sumx  ( 0 ) ;
      double sumy  ( 0 ) ;
      double sumz  ( 0 ) ;
      double sumx2 ( 0 ) ;
      double sumy2 ( 0 ) ;
      double sumz2 ( 0 ) ;
      unsigned int nsur ( sur.size()/4 ) ;

      const std::string names[10] = { "H0", "H1",  "H2",  "H3",  "H4", 
				      "V1", "V2",  "V3",  "V4",  "V5" } ;

      for( unsigned int i ( 0 ) ; i != nsur ; ++i )
      {
	 const HepPoint3D SA ( sur[4*i] ) ;
	 const HepPoint3D SB ( sur[4*i+1] ) ;
	 const HepPoint3D SC ( sur[4*i+2] ) ;
	 const HepPoint3D SD ( sur[4*i+3] ) ;
/*	 const HepPoint3D SB ( sur[4*i] ) ;
	 const HepPoint3D SC ( sur[4*i+1] ) ;
	 const HepPoint3D SD ( sur[4*i+2] ) ;
	 const HepPoint3D SA ( sur[4*i+3] ) ;*/

	 const HepPoint3D aa ( SA ) ;
	 const HepPoint3D bb ( SA + ( SB-SA ).unit()*(B0-A0).mag() ) ;

	 const HepPlane3D plane ( aa, bb, SC ) ;


	 const HepPoint3D cc ( bb + ( HepRotate3D( -angle, plane.normal() )*
				      HepVector3D( aa-bb ) ).unit()*( C0-B0 ).mag() ) ;

	 const HepTransform3D trform ( A0, B0, C0,
				       aa, bb, cc ) ;
	 const HepTransform3D trforminv ( aa, bb, cc,
					  A0, B0, C0 ) ;

	 const HepPoint3D dd ( trform*D0 ) ;


	 const HepTransform3D BeamLineToCMS ( H4ToBeamLine*aa,
					      H4ToBeamLine*bb,
					      H4ToBeamLine*cc,
					      A0, B0, C0 ) ;
	 const HepRotation blcmsrot ( BeamLineToCMS.getRotation() ) ;
	 const HepVector3D blcmstra ( BeamLineToCMS.getTranslation() ) ;

	 std::cout<<"\n********* Name is " << names[i] ;

	 std::cout<<"\n\n B discrepancy is "<< (bb-SB)<<", "<< (bb-SB).mag()
		  <<"\n\n C discrepancy is "<< (cc-SC)<<", "<< (cc-SC).mag()
		  <<"\n\n D discrepancy is "<< (dd-SD)<<", "<< (dd-SD).mag()
		  <<std::endl ;

	 const double dxbb ( bb.x() - SB.x() ) ;
	 const double dybb ( bb.y() - SB.y() ) ;
	 const double dzbb ( bb.z() - SB.z() ) ;

	 const double dxcc ( cc.x() - SC.x() ) ;
	 const double dycc ( cc.y() - SC.y() ) ;
	 const double dzcc ( cc.z() - SC.z() ) ;

	 const double dxdd ( dd.x() - SD.x() ) ;
	 const double dydd ( dd.y() - SD.y() ) ;
	 const double dzdd ( dd.z() - SD.z() ) ;

	 sumx  += dxdd ;//dxbb + dxcc + dxdd ;
	 sumy  += dydd ;//dybb + dycc + dydd ;
	 sumz  += dzdd ;//dzbb + dzcc + dzdd ;
	 sumx2 += dxdd*dxdd ;//dxbb*dxbb + dxcc*dxcc + dxdd*dxdd ;
	 sumy2 += dydd*dydd ;//dybb*dybb + dycc*dycc + dydd*dydd ;
	 sumz2 += dzdd*dzdd ;//dzbb*dzbb + dzcc*dzcc + dzdd*dzdd ;
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	 if( 0 == i )
	 {
	    const HepPoint3D ee ( trform*EE0 ) ;
	    const HepPoint3D ff ( trform*FF0 ) ;
	    const HepPoint3D gg ( trform*GG0 ) ;
	    const HepPoint3D hh ( trform*HH0 ) ;

	    std::cout<<"\n\n E discrepancy is "<< (ee-extra[0])<<", "<< (ee-extra[0]).mag()
		     <<"\n\n F discrepancy is "<< (ff-extra[1])<<", "<< (ff-extra[1]).mag()
		     <<"\n\n G discrepancy is "<< (gg-extra[2])<<", "<< (gg-extra[2]).mag()
		     <<"\n\n H discrepancy is "<< (hh-extra[3])<<", "<< (hh-extra[3]).mag()
		     <<std::endl ;


	    std::cout<<"\n Point SA in CMS coord = "<<trforminv*SA<<std::endl ;

	 }
	 const HepPoint3D cmsPiv ( trforminv*PIVOT ) ;
	 psumx += cmsPiv.x() ;
	 psumy += cmsPiv.y() ;
	 psumz += cmsPiv.z() ;
	 psumx2 += cmsPiv.x()*cmsPiv.x() ;
	 psumy2 += cmsPiv.y()*cmsPiv.y() ;
	 psumz2 += cmsPiv.z()*cmsPiv.z() ;

	 const HepRotation rotInv ( trforminv.getRotation() ) ; 

	 std::cout<<"\n CMS IP in H4 coord = "<<trform*IP<<std::endl ;
	 std::cout<<"\n Pivot point in CMS coord = "<<cmsPiv<<std::endl ;
//	 std::cout<<"\n\nTransform rotation is "<<rotInv
//		  <<"\n\n          translation="<<trforminv.getTranslation() <<std::endl ;

	 static const double kRadToDeg ( 180/M_PI ) ;

/*	 std::cout<<"\n"<<names[i]
		  <<"   Theta_x == "<<(blcmsrot*HepPoint3D(1,0,0)).theta()*kRadToDeg
		  <<",  Theta_y == "<<(blcmsrot*HepPoint3D(0,1,0)).theta()*kRadToDeg
		  <<",  Theta_z == "<<(blcmsrot*HepPoint3D(0,0,1)).theta()*kRadToDeg<<std::endl ;

	 std::cout<<"\n"<<names[i]
		  <<"   Phi_x == "<<(blcmsrot*HepPoint3D(1,0,0)).phi()*kRadToDeg
		  <<",  Phi_y == "<<(blcmsrot*HepPoint3D(0,1,0)).phi()*kRadToDeg
		  <<",  Phi_z == "<<(blcmsrot*HepPoint3D(0,0,1)).phi()*kRadToDeg<<std::endl ;
*/

	 std::cout<<"\n"<<names[i]
		  <<"   Theta_x = "<<blcmsrot.thetaX()*kRadToDeg
		  <<",  Theta_y = "<<blcmsrot.thetaY()*kRadToDeg
		  <<",  Theta_z = "<<blcmsrot.thetaZ()*kRadToDeg
		  <<",  eta = "<<-log(tan(blcmsrot.thetaZ()/2.))
		  <<std::endl ;

	 std::cout<<"\n"<<names[i]
		  <<"   Phi_x = "<<blcmsrot.phiX()*kRadToDeg
		  <<",  Phi_y = "<<blcmsrot.phiY()*kRadToDeg
		  <<",  Phi_z = "<<blcmsrot.phiZ()*kRadToDeg<<std::endl ;

	 std::cout<<"\n\n BeamLine to CMS translation"<<blcmstra<<std::endl ;
      }
      const double ntot ( 1.0*nsur ) ;
      sumx /= ntot ;
      sumy /= ntot ;
      sumz /= ntot ;
      sumx2 = sqrt( sumx2/ntot - sumx*sumx ) ;
      sumy2 = sqrt( sumy2/ntot - sumy*sumy ) ;
      sumz2 = sqrt( sumz2/ntot - sumz*sumz ) ;

      std::cout<<"\n Number of survey points = "<<ntot ;
      std::cout<<"\n====== Mean x deviation = "<< sumx <<" +- "<<sumx2 ;
      std::cout<<"\n====== Mean y deviation = "<< sumy <<" +- "<<sumy2 ;
      std::cout<<"\n====== Mean z deviation = "<< sumz <<" +- "<<sumz2 <<std::endl ;

      psumx /= ntot ;
      psumy /= ntot ;
      psumz /= ntot ;
      psumx2 = sqrt( psumx2/ntot - psumx*psumx ) ;
      psumy2 = sqrt( psumy2/ntot - psumy*psumy ) ;
      psumz2 = sqrt( psumz2/ntot - psumz*psumz ) ;

      std::cout<<"\n====== Mean x of pivot = "<< psumx <<" +- "<<psumx2 ;
      std::cout<<"\n====== Mean y of pivot = "<< psumy <<" +- "<<psumy2 ;
      std::cout<<"\n====== Mean z of pivot = "<< psumz <<" +- "<<psumz2 <<std::endl ;
   }
}

template <class T>
unsigned int 
CaloGeometryLoaderTest<T>::getDetIdForDDDNode( const DDFilteredView& fv )
{
  // perform some consistency checks
  // get the parents and grandparents of this node

  const DDGeoHistory& parents ( fv.geoHistory() ) ;
  const DDGeoHistory::size_type psize ( parents.size() ) ;

  EcalBaseNumber baseNumber ;
  baseNumber.setSize( psize ) ;

  for( unsigned int i=1 ; i<=psize ; ++i )
  {
     baseNumber.addLevel( parents[psize-i].logicalPart().name().name(),
			  parents[psize-i].copyno() ) ;
  }

  return baseNumber.getCopyNumber(0) ;


//  return m_scheme.getUnitID( baseNumber );  
}


#endif
