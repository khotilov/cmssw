#ifndef GEOMETRY_ECALGEOMETRYLOADER_ICC
#define GEOMETRY_ECALGEOMETRYLOADER_ICC 1

#include "CondFormats/Alignment/interface/AlignTransform.h"

#include "Geometry/EcalTestBeam/test/ee/CaloGeometryLoaderTest.h"

#include "Geometry/CaloGeometry/interface/CaloCellGeometry.h"

#include "Geometry/CaloGeometry/interface/CaloGenericDetId.h"

#include "DetectorDescription/Core/interface/DDCompactView.h"
#include "DetectorDescription/Core/interface/DDCurrentNamespace.h"
#include "DetectorDescription/Core/interface/DDLogicalPart.h"
#include "DetectorDescription/Core/interface/DDSolid.h"
#include "DetectorDescription/Core/interface/DDMaterial.h"
#include "DetectorDescription/Core/interface/DDTransform.h"
#include "DetectorDescription/Core/interface/DDCompactView.h"
#include "DetectorDescription/Core/interface/DDExpandedView.h"
#include "DetectorDescription/Core/interface/DDNodes.h"
#include "DetectorDescription/Core/interface/DDSpecifics.h"
#include "DetectorDescription/Core/interface/DDName.h"
#include "DetectorDescription/Core/interface/DDScope.h"
#include "DetectorDescription/Core/interface/DDFilter.h"
#include "DetectorDescription/Core/interface/DDQuery.h"
#include "DetectorDescription/Core/interface/DDFilteredView.h"
#include "DetectorDescription/ExprAlgo/interface/ExprEvalSingleton.h"

#include "CLHEP/Units/GlobalSystemOfUnits.h"
#include "CLHEP/Geometry/Plane3D.h"

#include <vector>
#include <fstream>

using namespace std;

template <class T>
const double 
CaloGeometryLoaderTest<T>::k_ScaleFromDDDtoGeant ( 0.1 ) ;

template <class T>
CaloGeometryLoaderTest<T>::CaloGeometryLoaderTest() 
{
   m_filter.setCriteria( DDValue( "Volume",
				  "EndcapSC",
//				  "EESCEnv1",
				  0                  ),
			 DDSpecificsFilter::equals    ) ;
//,
//			 DDSpecificsFilter::AND,
//			 true,
//			 true                       ) ;
}

template <class T>
typename CaloGeometryLoaderTest<T>::PtrType
CaloGeometryLoaderTest<T>::load( const DDCompactView*  cpv        ,
				 const Alignments*     alignments ,
				 const Alignments*     globals       ) 
{
   PtrType geom ( new T ) ;

   makeGeometry( cpv,
		 dynamic_cast<T*>( geom.get() ),
		 alignments,
		 globals ) ;

   return geom ;
}

template <class T>
void 
CaloGeometryLoaderTest<T>::makeGeometry( const DDCompactView*  cpv        ,
					 T*                    geom       ,
					 const Alignments*     alignments ,
					 const Alignments*     globals      )
{
   geom->allocateCorners( T::k_NumberOfCellsForCorners ) ;
   geom->allocatePar( T::k_NumberOfParametersPerShape*T::k_NumberOfShapes,
		      T::k_NumberOfParametersPerShape ) ;

   DDFilteredView fv ( *cpv ) ;
   fv.addFilter( m_filter ) ;

   unsigned int counter ( 0 ) ;
   for( bool doSubDets = fv.firstChild(); doSubDets ; doSubDets = fv.nextSibling() )
   {
      ++counter ;
      const DDSolid& solid ( fv.logicalPart().solid() ) ;
      
      const ParmVec& parameters ( solid.parameters() ) ;

      DD3Vector x, y, z;
      fv.rotation().GetComponents( x, y, z ) ;
      const CLHEP::HepRep3x3 temp( x.X(), y.X(), z.X(),
				   x.Y(), y.Y(), z.Y(),
			           x.Z(), y.Z(), z.Z() );
      const CLHEP::HepRotation hr ( temp );
      const CLHEP::Hep3Vector h3v ( fv.translation().X(),
		 		    fv.translation().Y(),
				    fv.translation().Z()  ) ;
      const HepGeom::Transform3D ht3d ( hr,          // only scale translation
	 	 		        k_ScaleFromDDDtoGeant*h3v ) ;    


      const unsigned int id ( getDetIdForDDDNode( fv ) ) ;

      myFillGeom( geom, parameters, ht3d, id ) ;
   }
}


template <class T>
void
CaloGeometryLoaderTest<T>::myFillGeom( T*                    geom ,
				       const ParmVec&          vv ,
				       const HepGeom::Transform3D&   tr ,
				       const unsigned int      id     )
{
   static const double kRadToDeg ( 180/M_PI ) ;
   static const HepPoint3D PIVOT ( 13533.35, -000.02, 0 ) ;//-152.23 ) ;
   static const HepPoint3D FLOOR ( 13533.35, -000.02, -152.23 ) ;//-152.23 ) ;

   static const HepPoint3D IP    ( 0, 0, 0 ) ;//-152.23 ) ;
   static HepPoint3D AA0 ;
   static HepPoint3D BB0 ;
   static HepPoint3D CC0 ;
   static HepPoint3D DD0 ;
   static HepPoint3D EE0 ;
   static HepPoint3D FF0 ;
   static HepPoint3D GG0 ;
   static HepPoint3D HH0 ;

   std::vector<double> pv ;
   pv.reserve( vv.size() ) ;
   for( unsigned int i ( 0 ) ; i != vv.size() ; ++i )
   {
      const double factor ( 1==i || 2==i || 6==i || 10==i ? 1 : k_ScaleFromDDDtoGeant ) ;
      pv.push_back( factor*vv[i] ) ;
   }

   CaloCellGeometry::CornersVec corners ( geom->cornersMgr() ) ;
   corners.resize() ;

   TruncatedPyramid::createCorners( pv, tr, corners ) ;

   if( ( 160 == id ||
	 164 == id ||
	 134 == id ||
	 133 == id ||
	 153 == id ||
	 150 == id ||
	 130 == id    ) &&
       ( 0 < corners[0].x() &&
	 0 < corners[0].y() &&
	 0 < corners[0].z()    ) )
   {
/*      std::cout<<"\n *************** id = "<<id
	       <<"\n "<<corners[0]
	       <<"\n "<<corners[1]
	       <<"\n "<<corners[2]
	       <<"\n "<<corners[3]
	       <<"\n "<<corners[4]
	       <<"\n "<<corners[5]
	       <<"\n "<<corners[6]
	       <<"\n "<<corners[7]
	       <<std::endl ;*/

      if( 160 == id ) AA0 = HepPoint3D( corners[3].x(),
				       corners[3].y(),
				       corners[3].z() ) ;
      if( 164 == id ) BB0 = HepPoint3D( corners[2].x(),
				       corners[2].y(),
				       corners[2].z() ) ;
      if( 134 == id ) CC0 = HepPoint3D( corners[1].x(),
				       corners[1].y(),
				       corners[1].z() ) ;
      if( 130 == id ) DD0 = HepPoint3D( corners[0].x(),
				       corners[0].y(),
				       corners[0].z() ) ;
      if( 150 == id ) EE0 = HepPoint3D( corners[2].x(),
					corners[2].y(),
					corners[2].z() ) ;
      if( 153 == id ) FF0 = HepPoint3D( corners[2].x(),
					corners[2].y(),
					corners[2].z() ) ;
      if( 133 == id ) GG0 = HepPoint3D( corners[2].x(),
					corners[2].y(),
					corners[2].z() ) ;
      if( 130 == id ) HH0 = HepPoint3D( corners[2].x(),
					corners[2].y(),
					corners[2].z() ) ;
   }
   static bool done (false) ;
   if( 0.001 < AA0.mag() &&
       0.001 < BB0.mag() &&
       0.001 < CC0.mag() &&
       0.001 < DD0.mag() &&
       !done                  )
   {
      done = true ;

      const HepTransform3D H4ToBeamLine ( PIVOT + HepPoint3D( 0, 1, 0),
					  PIVOT + HepPoint3D( 0, 0, 1),
					  PIVOT + HepPoint3D( 1, 0, 0),
					  HepPoint3D( 0, -1, 0),
					  HepPoint3D( 1,  0, 0),
					  HepPoint3D( 0,  0, 1) ) ;

      std::cout<<"pivot to beamline="<<H4ToBeamLine*PIVOT<<std::endl ;
      std::cout<<"endcap to beamline="<<H4ToBeamLine*HepPoint3D(PIVOT.x()+316,0,50)
	       <<std::endl ;


      std::cout<<"\nA0 = "<<AA0
	       <<"\nB0 = "<<BB0
	       <<"\nC0 = "<<CC0
	       <<"\nD0 = "<<DD0
	       << std::endl ;

      const HepPoint3D A0 (AA0) ;
      const HepPoint3D B0 (BB0) ;
      const HepPoint3D C0 (CC0) ;
      const HepPoint3D D0 (DD0) ;

      const double angle ( (C0-B0).angle( A0-B0 ) ) ;

      static std::vector< HepPoint3D > extra ;
      extra.push_back( HepPoint3D(  13859.05,  005.79, -002.66 ) ) ;
      extra.push_back( HepPoint3D(  13860.98, -038.39, -002.11 ) ) ;
      extra.push_back( HepPoint3D(  13853.19, -039.25, -030.77 ) ) ;
      extra.push_back( HepPoint3D(  13851.23,  004.99, -031.39 ) ) ;



      static std::vector< HepPoint3D > sur ;
      sur.push_back( HepPoint3D( 13862.30,  20.68, 11.60 ) ) ;
      sur.push_back( HepPoint3D( 13865.69, -52.85, 12.64) ) ;
      sur.push_back( HepPoint3D( 13851.53, -54.27, -44.75 ) ) ;
      sur.push_back( HepPoint3D( 13848.21,  19.18, -45.89 ) ) ;

      sur.push_back( HepPoint3D( 13861.72,   28.62,   11.61 ) ) ;
      sur.push_back( HepPoint3D( 13866.88,  -44.81,   12.64 ) ) ;
      sur.push_back( HepPoint3D( 13852.76,  -46.56,  -44.73 ) ) ;
      sur.push_back( HepPoint3D( 13847.67,   26.79,  -45.88 ) ) ;
      sur.push_back( HepPoint3D( 13856.82,   63.41,   11.60 ) ) ;
      sur.push_back( HepPoint3D( 13869.76,   -9.06,   12.64 ) ) ;
      sur.push_back( HepPoint3D( 13855.90,  -12.31,  -44.73 ) ) ;
      sur.push_back( HepPoint3D( 13843.04,   60.08,  -45.89 ) ) ;
      sur.push_back( HepPoint3D( 13860.86,  -36.96,   11.60 ) ) ;
      sur.push_back( HepPoint3D( 13851.38, -109.96,   12.63 ) ) ;
      sur.push_back( HepPoint3D( 13837.21, -108.89,  -44.73 ) ) ;
      sur.push_back( HepPoint3D( 13846.73,  -35.98,  -45.88 ) ) ;
      sur.push_back( HepPoint3D( 13854.03,  -76.21,   11.60 ) ) ;
      sur.push_back( HepPoint3D( 13835.82, -147.53,   12.64 ) ) ;
      sur.push_back( HepPoint3D( 13821.88, -144.76,  -44.73 ) ) ;
      sur.push_back( HepPoint3D( 13840.13,  -73.54,  -45.88 ) ) ;
      sur.push_back( HepPoint3D( 13861.10,   35.48,   09.88 ) ) ;
      sur.push_back( HepPoint3D( 13867.78,  -37.82,   11.07 ) ) ;
      sur.push_back( HepPoint3D( 13853.42,  -40.01,  -46.22 ) ) ;
      sur.push_back( HepPoint3D( 13846.80,   33.21,  -47.52 ) ) ;
      sur.push_back( HepPoint3D( 13860.68,   35.23,   19.89 ) ) ;
      sur.push_back( HepPoint3D( 13867.35,  -38.08,   20.23 ) ) ;
      sur.push_back( HepPoint3D( 13854.67,  -39.43,  -37.48 ) ) ;
      sur.push_back( HepPoint3D( 13848.07,   33.79,  -37.92 ) ) ;
      sur.push_back( HepPoint3D( 13859.95,   34.97,   29.87 ) ) ;
      sur.push_back( HepPoint3D( 13866.62,  -38.34,   29.33 ) ) ;
      sur.push_back( HepPoint3D( 13855.61,  -38.88,  -28.76 ) ) ;
      sur.push_back( HepPoint3D( 13849.00,   34.34,  -28.32 ) ) ;
      sur.push_back( HepPoint3D( 13858.93,   34.41,   39.81 ) ) ;
      sur.push_back( HepPoint3D( 13865.65,  -38.90,   38.40 ) ) ;
      sur.push_back( HepPoint3D( 13856.34,  -38.58,  -19.97 ) ) ;
      sur.push_back( HepPoint3D( 13849.70,   34.65,  -18.68 ) ) ;
      sur.push_back( HepPoint3D( 13857.67,   33.69,   49.76 ) ) ;
      sur.push_back( HepPoint3D( 13864.43,  -39.60,   47.48 ) ) ;
      sur.push_back( HepPoint3D( 13856.81,  -38.43,  -11.13 ) ) ;
      sur.push_back( HepPoint3D( 13850.14,   34.78,   -8.95 ) ) ;
      
      double fsumx  ( 0 ) ;
      double fsumy  ( 0 ) ;
      double fsumz  ( 0 ) ;
      double fsumx2 ( 0 ) ;
      double fsumy2 ( 0 ) ;
      double fsumz2 ( 0 ) ;

      double psumx  ( 0 ) ;
      double psumy  ( 0 ) ;
      double psumz  ( 0 ) ;
      double psumx2 ( 0 ) ;
      double psumy2 ( 0 ) ;
      double psumz2 ( 0 ) ;

      double sumx  ( 0 ) ;
      double sumy  ( 0 ) ;
      double sumz  ( 0 ) ;
      double sumx2 ( 0 ) ;
      double sumy2 ( 0 ) ;
      double sumz2 ( 0 ) ;
      unsigned int nsur ( sur.size()/4 ) ;

      const std::string names[10] = { "H0", "H1",  "H2",  "H3",  "H4", 
				      "V1", "V2",  "V3",  "V4",  "V5" } ;


      HepTransform3D V3Transform ;

      for( unsigned int i ( 0 ) ; i != nsur ; ++i )
      {
	 const HepPoint3D SA ( sur[4*i] ) ;
	 const HepPoint3D SB ( sur[4*i+1] ) ;
	 const HepPoint3D SC ( sur[4*i+2] ) ;
	 const HepPoint3D SD ( sur[4*i+3] ) ;
/*	 const HepPoint3D SB ( sur[4*i] ) ;
	 const HepPoint3D SC ( sur[4*i+1] ) ;
	 const HepPoint3D SD ( sur[4*i+2] ) ;
	 const HepPoint3D SA ( sur[4*i+3] ) ;*/

	 const HepPoint3D aa ( SA ) ;
	 const HepPoint3D bb ( SA + ( SB-SA ).unit()*(B0-A0).mag() ) ;

	 const HepPlane3D plane ( aa, bb, SC ) ;


	 const HepPoint3D cc ( bb + ( HepRotate3D( -angle, plane.normal() )*
				      HepVector3D( aa-bb ) ).unit()*( C0-B0 ).mag() ) ;

	 const HepTransform3D trform ( A0, B0, C0,
				       aa, bb, cc ) ;

	 const HepTransform3D trforminv ( aa, bb, cc,
					  A0, B0, C0 ) ;

	 const HepPoint3D dd ( trform*D0 ) ;


	 const HepTransform3D BeamLineToCMS ( H4ToBeamLine*aa,
					      H4ToBeamLine*bb,
					      H4ToBeamLine*cc,
					      A0, B0, C0 ) ;

	 if( 7 == i ) V3Transform = BeamLineToCMS ;

	 const HepRotation blcmsrot ( BeamLineToCMS.getRotation() ) ;
	 const HepVector3D blcmstra ( BeamLineToCMS.getTranslation() ) ;

	 std::cout<<"\n********* Name is " << names[i] ;

	 std::cout<<"\n\n B discrepancy is "<< (bb-SB)<<", "<< (bb-SB).mag()
		  <<"\n\n C discrepancy is "<< (cc-SC)<<", "<< (cc-SC).mag()
		  <<"\n\n D discrepancy is "<< (dd-SD)<<", "<< (dd-SD).mag()
		  <<std::endl ;
/*
	 const double dxbb ( bb.x() - SB.x() ) ;
	 const double dybb ( bb.y() - SB.y() ) ;
	 const double dzbb ( bb.z() - SB.z() ) ;

	 const double dxcc ( cc.x() - SC.x() ) ;
	 const double dycc ( cc.y() - SC.y() ) ;
	 const double dzcc ( cc.z() - SC.z() ) ;
*/
	 const double dxdd ( dd.x() - SD.x() ) ;
	 const double dydd ( dd.y() - SD.y() ) ;
	 const double dzdd ( dd.z() - SD.z() ) ;

	 sumx  += dxdd ;//dxbb + dxcc + dxdd ;
	 sumy  += dydd ;//dybb + dycc + dydd ;
	 sumz  += dzdd ;//dzbb + dzcc + dzdd ;
	 sumx2 += dxdd*dxdd ;//dxbb*dxbb + dxcc*dxcc + dxdd*dxdd ;
	 sumy2 += dydd*dydd ;//dybb*dybb + dycc*dycc + dydd*dydd ;
	 sumz2 += dzdd*dzdd ;//dzbb*dzbb + dzcc*dzcc + dzdd*dzdd ;
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	 if( 0 == i )
	 {
	    const HepPoint3D ee ( trform*EE0 ) ;
	    const HepPoint3D ff ( trform*FF0 ) ;
	    const HepPoint3D gg ( trform*GG0 ) ;
	    const HepPoint3D hh ( trform*HH0 ) ;

	    std::cout<<"\n\n E discrepancy is "<< (ee-extra[0])<<", "<< (ee-extra[0]).mag()
		     <<"\n\n F discrepancy is "<< (ff-extra[1])<<", "<< (ff-extra[1]).mag()
		     <<"\n\n G discrepancy is "<< (gg-extra[2])<<", "<< (gg-extra[2]).mag()
		     <<"\n\n H discrepancy is "<< (hh-extra[3])<<", "<< (hh-extra[3]).mag()
		     <<std::endl ;


	    std::cout<<"\n Point SA in CMS coord = "<<trforminv*SA<<std::endl ;

	 }
	 const HepPoint3D cmsPiv ( trforminv*PIVOT ) ;
	 psumx += cmsPiv.x() ;
	 psumy += cmsPiv.y() ;
	 psumz += cmsPiv.z() ;
	 psumx2 += cmsPiv.x()*cmsPiv.x() ;
	 psumy2 += cmsPiv.y()*cmsPiv.y() ;
	 psumz2 += cmsPiv.z()*cmsPiv.z() ;
	 const HepPoint3D cmsFlr ( trforminv*FLOOR ) ;
	 fsumx += cmsFlr.x() ;
	 fsumy += cmsFlr.y() ;
	 fsumz += cmsFlr.z() ;
	 fsumx2 += cmsFlr.x()*cmsFlr.x() ;
	 fsumy2 += cmsFlr.y()*cmsFlr.y() ;
	 fsumz2 += cmsFlr.z()*cmsFlr.z() ;

	 const HepRotation rotInv ( trforminv.getRotation() ) ; 

	 std::cout<<"\n CMS IP in H4 coord = "<<trform*IP<<std::endl ;
	 std::cout<<"\n Pivot point in CMS coord = "<<cmsPiv<<std::endl ;
	 std::cout<<"\n Floor point in CMS coord = "<<cmsFlr<<std::endl ;
//	 std::cout<<"\n\nTransform rotation is "<<rotInv
//		  <<"\n\n          translation="<<trforminv.getTranslation() <<std::endl ;


/*	 std::cout<<"\n"<<names[i]
		  <<"   Theta_x == "<<(blcmsrot*HepPoint3D(1,0,0)).theta()*kRadToDeg
		  <<",  Theta_y == "<<(blcmsrot*HepPoint3D(0,1,0)).theta()*kRadToDeg
		  <<",  Theta_z == "<<(blcmsrot*HepPoint3D(0,0,1)).theta()*kRadToDeg<<std::endl ;

	 std::cout<<"\n"<<names[i]
		  <<"   Phi_x == "<<(blcmsrot*HepPoint3D(1,0,0)).phi()*kRadToDeg
		  <<",  Phi_y == "<<(blcmsrot*HepPoint3D(0,1,0)).phi()*kRadToDeg
		  <<",  Phi_z == "<<(blcmsrot*HepPoint3D(0,0,1)).phi()*kRadToDeg<<std::endl ;
*/

	 std::cout<<"\n"<<names[i]
		  <<"   Theta_x = "<<blcmsrot.thetaX()*kRadToDeg
		  <<",  Theta_y = "<<blcmsrot.thetaY()*kRadToDeg
		  <<",  Theta_z = "<<blcmsrot.thetaZ()*kRadToDeg
		  <<",  eta = "<<-log(tan(blcmsrot.thetaZ()/2.))
		  <<std::endl ;

	 std::cout<<"\n"<<names[i]
		  <<"   Phi_x = "<<blcmsrot.phiX()*kRadToDeg
		  <<",  Phi_y = "<<blcmsrot.phiY()*kRadToDeg
		  <<",  Phi_z = "<<blcmsrot.phiZ()*kRadToDeg<<std::endl ;

	 std::cout<<"\n\n BeamLine to CMS translation"<<blcmstra<<std::endl ;
      }
      const double ntot ( 1.0*nsur ) ;
      sumx /= ntot ;
      sumy /= ntot ;
      sumz /= ntot ;
      sumx2 = sqrt( sumx2/ntot - sumx*sumx ) ;
      sumy2 = sqrt( sumy2/ntot - sumy*sumy ) ;
      sumz2 = sqrt( sumz2/ntot - sumz*sumz ) ;

      std::cout<<"\n Number of survey points = "<<ntot ;
      std::cout<<"\n====== Mean x deviation = "<< sumx <<" +- "<<sumx2 ;
      std::cout<<"\n====== Mean y deviation = "<< sumy <<" +- "<<sumy2 ;
      std::cout<<"\n====== Mean z deviation = "<< sumz <<" +- "<<sumz2 <<std::endl ;

      psumx /= ntot ;
      psumy /= ntot ;
      psumz /= ntot ;
      psumx2 = sqrt( psumx2/ntot - psumx*psumx ) ;
      psumy2 = sqrt( psumy2/ntot - psumy*psumy ) ;
      psumz2 = sqrt( psumz2/ntot - psumz*psumz ) ;

      std::cout<<"\n====== Mean x of pivot = "<< psumx <<" +- "<<psumx2 ;
      std::cout<<"\n====== Mean y of pivot = "<< psumy <<" +- "<<psumy2 ;
      std::cout<<"\n====== Mean z of pivot = "<< psumz <<" +- "<<psumz2 <<std::endl ;

      fsumx /= ntot ;
      fsumy /= ntot ;
      fsumz /= ntot ;
      fsumx2 = sqrt( fsumx2/ntot - fsumx*fsumx ) ;
      fsumy2 = sqrt( fsumy2/ntot - fsumy*fsumy ) ;
      fsumz2 = sqrt( fsumz2/ntot - fsumz*fsumz ) ;

      std::cout<<"\n====== Mean x of floor = "<< fsumx <<" +- "<<fsumx2 ;
      std::cout<<"\n====== Mean y of floor = "<< fsumy <<" +- "<<fsumy2 ;
      std::cout<<"\n====== Mean z of floor = "<< fsumz <<" +- "<<fsumz2 <<std::endl ;

      const HepVector3D hpl[] = { HepPlane3D( sur[16], sur[0], sur[8] ).normal(),
				  HepPlane3D( sur[17], sur[1], sur[9] ).normal(),
				  HepPlane3D( sur[18], sur[2], sur[10]).normal(),
				  HepPlane3D( sur[19], sur[3], sur[11]).normal(),
				  HepPlane3D( sur[16], sur[12], sur[8] ).normal(),
				  HepPlane3D( sur[17], sur[13], sur[9] ).normal(),
				  HepPlane3D( sur[18], sur[14], sur[10]).normal(),
				  HepPlane3D( sur[19], sur[15], sur[11]).normal()   } ;

      const HepVector3D hplavr ( 0.125*( hpl[0] + hpl[1] + hpl[2] + hpl[3] +
					 hpl[4] + hpl[5] + hpl[6] + hpl[7]  ) ) ; 

      std::cout<<"\n\n+++ HNormal for A ="<< hpl[0].theta()*kRadToDeg <<", "<<hpl[0].phi()*kRadToDeg
	       <<  "\n+++ HNormal for B ="<< hpl[1].theta()*kRadToDeg <<", "<<hpl[1].phi()*kRadToDeg
	       <<  "\n+++ HNormal for C ="<< hpl[2].theta()*kRadToDeg <<", "<<hpl[2].phi()*kRadToDeg
	       <<  "\n+++ HNormal for D ="<< hpl[3].theta()*kRadToDeg <<", "<<hpl[3].phi()*kRadToDeg
	       <<  "\n+++ HNormal for A ="<< hpl[4].theta()*kRadToDeg <<", "<<hpl[4].phi()*kRadToDeg
	       <<  "\n+++ HNormal for B ="<< hpl[5].theta()*kRadToDeg <<", "<<hpl[5].phi()*kRadToDeg
	       <<  "\n+++ HNormal for C ="<< hpl[6].theta()*kRadToDeg <<", "<<hpl[6].phi()*kRadToDeg
	       <<  "\n+++ HNormal for D ="<< hpl[7].theta()*kRadToDeg <<", "<<hpl[7].phi()*kRadToDeg
	       <<  "\n+++ HAverage      ="<< hplavr.theta()*kRadToDeg <<", "<<hplavr.phi()*kRadToDeg
	       << std::endl; 

      const HepVector3D vpl[] = { HepPlane3D( sur[20], sur[28], sur[36] ).normal(),
				  HepPlane3D( sur[21], sur[29], sur[37] ).normal(),
				  HepPlane3D( sur[22], sur[30], sur[38]).normal(),
				  HepPlane3D( sur[23], sur[31], sur[39]).normal(),

				  HepPlane3D( sur[20], sur[24], sur[36] ).normal(),
				  HepPlane3D( sur[21], sur[25], sur[37] ).normal(),
				  HepPlane3D( sur[22], sur[26], sur[38]).normal(),
				  HepPlane3D( sur[23], sur[27], sur[39]).normal(),

				  HepPlane3D( sur[20], sur[32], sur[36] ).normal(),
				  HepPlane3D( sur[21], sur[33], sur[37] ).normal(),
				  HepPlane3D( sur[22], sur[34], sur[38]).normal(),
				  HepPlane3D( sur[23], sur[35], sur[39]).normal(),

				  HepPlane3D( sur[20], sur[32], sur[36] ).normal(),
				  HepPlane3D( sur[21], sur[33], sur[37] ).normal(),
				  HepPlane3D( sur[22], sur[34], sur[38]).normal(),
				  HepPlane3D( sur[23], sur[35], sur[39]).normal()
      } ;

      const HepVector3D vplavr ( 0.0625*( vpl[0] + vpl[1] + vpl[2] + vpl[3] +
					  vpl[4] + vpl[5] + vpl[6] + vpl[7] +
					  vpl[8] + vpl[9] + vpl[10] + vpl[11] +
					  vpl[12] + vpl[13] + vpl[14] + vpl[15]  ) ) ; 

      std::cout<<"\n\n+++ VNormal for A ="<< vpl[0].theta()*kRadToDeg <<", "<<vpl[0].phi()*kRadToDeg
	       <<  "\n+++ VNormal for B ="<< vpl[1].theta()*kRadToDeg <<", "<<vpl[1].phi()*kRadToDeg
	       <<  "\n+++ VNormal for C ="<< vpl[2].theta()*kRadToDeg <<", "<<vpl[2].phi()*kRadToDeg
	       <<  "\n+++ VNormal for D ="<< vpl[3].theta()*kRadToDeg <<", "<<vpl[3].phi()*kRadToDeg
	       <<  "\n+++ VNormal for A ="<< vpl[4].theta()*kRadToDeg <<", "<<vpl[4].phi()*kRadToDeg
	       <<  "\n+++ VNormal for B ="<< vpl[5].theta()*kRadToDeg <<", "<<vpl[5].phi()*kRadToDeg
	       <<  "\n+++ VNormal for C ="<< vpl[6].theta()*kRadToDeg <<", "<<vpl[6].phi()*kRadToDeg
	       <<  "\n+++ VNormal for D ="<< vpl[7].theta()*kRadToDeg <<", "<<vpl[7].phi()*kRadToDeg
	       <<  "\n+++ VNormal for A ="<< vpl[8].theta()*kRadToDeg <<", "<<vpl[8].phi()*kRadToDeg
	       <<  "\n+++ VNormal for B ="<< vpl[9].theta()*kRadToDeg <<", "<<vpl[9].phi()*kRadToDeg
	       <<  "\n+++ VNormal for C ="<< vpl[10].theta()*kRadToDeg <<", "<<vpl[10].phi()*kRadToDeg
	       <<  "\n+++ VNormal for D ="<< vpl[11].theta()*kRadToDeg <<", "<<vpl[11].phi()*kRadToDeg
	       <<  "\n+++ VNormal for A ="<< vpl[12].theta()*kRadToDeg <<", "<<vpl[12].phi()*kRadToDeg
	       <<  "\n+++ VNormal for B ="<< vpl[13].theta()*kRadToDeg <<", "<<vpl[13].phi()*kRadToDeg
	       <<  "\n+++ VNormal for C ="<< vpl[14].theta()*kRadToDeg <<", "<<vpl[14].phi()*kRadToDeg
	       <<  "\n+++ VNormal for D ="<< vpl[15].theta()*kRadToDeg <<", "<<vpl[15].phi()*kRadToDeg
	       <<  "\n+++ VAverage      ="<< vplavr.theta()*kRadToDeg <<", "<<vplavr.phi()*kRadToDeg
	       << std::endl; 

      unsigned int Hinput ( 0 ) ;
      unsigned int Vinput ( 0 ) ;

      std::cout<<"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
	       <<"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
	       <<"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
	       <<"\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" 
	       <<"\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" 
	       <<"\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" 
	       <<"\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" 
	       <<"\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" 
	       <<"\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" 
	       <<"\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
	       << std::endl ;

      bool keepGoing ( true ) ;
      while( keepGoing )
      {

	 std::cout<<"\n\n+++ Preparing to make two files for the table position you specify" ;

	 std::cout<<"\n\n**Enter desired H position (integer, 25000-300000) [0 to quit]: "<<std::ends ;
	 std::cin>>Hinput ;

	 keepGoing = ( 0 != Hinput ) ;

	 if( keepGoing )
	 {
	    std::cout<<"\n\n**Enter desired V position (integer, 5000-30000): "<<std::ends ;
	    std::cin>>Vinput ;

	    std::cout<<"\n\nH input value ="<<Hinput<<", V input value ="<<Vinput<<std::endl ;

	    if(  25000 > Hinput ||
		300000 < Hinput ||
		  5000 > Vinput ||
		 30000 < Vinput    )
	    {
	       std::cout<<"!!!!!!!! Invalid input(s), try again !!!!!!!"<<std::endl ;
	    }
	    else
	    {
	       // calculate transform parameters ================================================


//	       const HepPlane3D plaV ( sur[20], sur[28], sur[36] ) ;
//	       const double angleVPerUnit ( ( plaV.point( sur[36] ) - PIVOT ).angle(
//					       plaV.point( sur[20] ) - PIVOT ) ) ;

//	       const HepPlane3D plaH ( sur[16], sur[0], sur[8] ) ;
//	       const double angleHPerUnit ( ( plaH.point( sur[8] ) - PIVOT ).angle(
//					       plaH.point( sur[16] ) - PIVOT ) ) ;

	       const double angleHPerUnit ( ( sur[8] - PIVOT ).angle( sur[16] - PIVOT )/176458. ) ;
	       std::cout<<"angleHPerUnit="<<kRadToDeg*angleHPerUnit*1.e3<<std::endl ;

	       const double angleVPerUnit ( ( sur[36] - PIVOT ).angle( sur[20] - PIVOT )/16000. ) ;
	       std::cout<<"angleVPerUnit="<<kRadToDeg*angleVPerUnit*1.e3<<std::endl ;

	       const HepRotate3D  vRotate ( ( Vinput -  16000 )*angleVPerUnit, vpl[0] ) ;
	       const HepRotateZ3D hRotate ( ( Hinput - 191000 )*angleHPerUnit ) ;

	       const HepTransform3D myTrf ( V3Transform*hRotate*vRotate ) ;

	       const HepRotation myRot  ( myTrf.getRotation()    ) ;
	       const HepVector3D myTran ( myTrf.getTranslation() ) ;
	       
	       const double TthetaX ( myRot.thetaX() ) ;
	       const double TthetaY ( myRot.thetaY() ) ;
	       const double TthetaZ ( myRot.thetaZ() ) ;
	       const double TphiX   ( myRot.phiX() ) ;
	       const double TphiY   ( myRot.phiY() ) ;
	       const double TphiZ   ( myRot.phiZ() ) ;
	       const double Txtra   ( myTran.x() ) ;
	       const double Tytra   ( myTran.y() ) ;
	       const double Tztra   ( myTran.z() ) ;
	       const double TetaZ   ( -log(tan(TthetaZ/2.)) ) ;
	    
	       // write to files ================================================================

	       std::stringstream ssTxtra ;
	       ssTxtra<<std::setw(7) << setiosflags( ios::fixed ) << std::setprecision(5) 
		      << Txtra << "*cm" ;
	       const std::string strTxtra ( ssTxtra.str() ) ;
	       std::stringstream ssTytra ;
	       ssTytra<<std::setw(7) << setiosflags( ios::fixed ) << std::setprecision(5) 
		      << Tytra << "*cm" ;
	       const std::string strTytra ( ssTytra.str() ) ;
	       std::stringstream ssTztra ;
	       ssTztra<<std::setw(7) << setiosflags( ios::fixed ) << std::setprecision(5) 
		      << Tztra << "*cm" ;
	       const std::string strTztra ( ssTztra.str() ) ;

	       std::stringstream ssTetaZ ;
	       ssTetaZ<<std::setw(7) << setiosflags( ios::fixed ) << std::setprecision(5) 
		      << TetaZ ;
	       const std::string strTetaZ ( ssTetaZ.str() ) ;

	       std::stringstream ssTthetaX ;
	       ssTthetaX<<std::setw(7) << setiosflags( ios::fixed ) << std::setprecision(5) 
			<< TthetaX*kRadToDeg << "*deg" ;
	       const std::string strTthetaX ( ssTthetaX.str() ) ;
	       std::stringstream ssTphiX ;
	       ssTphiX<<std::setw(7) << setiosflags( ios::fixed ) << std::setprecision(5)
		      << TphiX*kRadToDeg << "*deg" ;
	       const std::string strTphiX ( ssTphiX.str() ) ;

	       std::stringstream ssTthetaY ;
	       ssTthetaY<<std::setw(7) << setiosflags( ios::fixed ) << std::setprecision(5) 
			<< TthetaY*kRadToDeg << "*deg" ;
	       const std::string strTthetaY ( ssTthetaY.str() ) ;
	       std::stringstream ssTphiY ;
	       ssTphiY<<std::setw(7) << setiosflags( ios::fixed ) << std::setprecision(5)
		      << TphiY*kRadToDeg << "*deg" ;
	       const std::string strTphiY ( ssTphiY.str() ) ;
	    
	       std::stringstream ssTthetaZ ;
	       ssTthetaZ<<std::setw(7) << setiosflags( ios::fixed ) << std::setprecision(5) 
			<< TthetaZ*kRadToDeg << "*deg" ;
	       const std::string strTthetaZ ( ssTthetaZ.str() ) ;
	       std::stringstream ssTphiZ ;
	       ssTphiZ<<std::setw(7) << setiosflags( ios::fixed ) << std::setprecision(5)
		      << TphiZ*kRadToDeg << "*deg" ;
	       const std::string strTphiZ ( ssTphiZ.str() ) ;
	       std::stringstream ssTphiZr ;
	       ssTphiZr<<std::setw(7) << setiosflags( ios::fixed ) << std::setprecision(5)
		       << TphiZ ;
	       const std::string strTphiZr ( ssTphiZr.str() ) ;
	       //-------------- first tbrot file ---------------------------
	       std::stringstream ss ;
	       ss<<"tbrot_H"<<std::setw(6)<<std::setfill('0')<< Hinput 
		 <<"_V"<<std::setw(5)<<std::setfill('0')<< Vinput 
		 <<".xml"<<std::ends ;
	       const std::string myname ( ss.str() ) ;

	       std::ofstream tbrotfile ( myname.c_str() ) ;

	       tbrotfile<<"<?xml version=\"1.0\"?>"
			<<"<DDDefinition xmlns=\"http://www.cern.ch/cms/DDL\""
			<<"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
			<<"xsi:schemaLocation=\"http://www.cern.ch/cms/DDL ../../"
			<<"DetectorDescription/Schema/DDLSchema.xsd\">"
			<<"\n\n<ConstantsSection  label=\"tbrot.xml\" eval=\"true\" >"
			<<"\n\n<Constant name=\"eta\"        value=\""<<strTetaZ<<"\"/>"
//			<<"\n\n<Constant name=\"theta\"      value=\"2*atan(exp(-[tbrot:eta]))\"/>"
			<<"\n\n<Constant name=\"theta\"      value=\""<<strTthetaZ<<"\"/>"
			<<"\n\n<Constant name=\"phi\"        value=\""<<strTphiZ<<"\"/>"
			<<"\n\n<Constant name=\"theta_X\"    value=\""<<strTthetaX<<"\"/>"
			<<"\n\n<Constant name=\"phi_X\"      value=\""<<strTphiX<<"\"/>"
			<<"\n\n<Constant name=\"theta_Y\"    value=\""<<strTthetaY<<"\"/>"
			<<"\n\n<Constant name=\"phi_Y\"      value=\""<<strTphiY<<"\"/>"
			<<"\n\n<Constant name=\"xtran\"        value=\""<<strTxtra<<"\"/>"
			<<"\n<Constant name=\"ytran\"        value=\""<<strTytra<<"\"/>"
			<<"\n<Constant name=\"ztran\"        value=\""<<strTztra<<"\"/>"
			<<"\n\n</ConstantsSection>"
			<<"\n\n</DDDefinition>"
			<<std::endl ;
	    
	       tbrotfile.close() ;
	    
	       //--------------- now beam paramter file ----------------------

	       std::stringstream ss2 ;
	       ss2<<"ee_beam_H"<<std::setw(6)<<std::setfill('0')<< Hinput 
		  <<"_V"<<std::setw(5)<<std::setfill('0')<< Vinput 
		  <<"_cff.py"<<std::ends ;
	       const std::string myname2 ( ss2.str() ) ;

	       std::ofstream beamfile ( myname2.c_str() ) ;

	       beamfile<<"import FWCore.ParameterSet.Config as cms"
		       <<"\n\n common_beam_direction_parameters = cms.PSet("
		       <<"\n    MinEta = cms.double("<< strTetaZ <<"),"
		       <<"\n    MaxEta = cms.double("<< strTetaZ <<"),"
		       <<"\n    MinPhi = cms.double("<< strTphiZr <<"),"
		       <<"\n    MaxPhi = cms.double("<< strTphiZr <<"),"
		       <<"\n    BeamMeanX = cms.double(0.0),"
		       <<"\n    BeamMeanY = cms.double(0.0),"
		       <<"\n    BeamPosition = cms.double(-26733.5)\n    )"
		       <<std::endl;
	    
	       beamfile.close() ;
	    }
	 }
      }
   }
}

template <class T>
unsigned int 
CaloGeometryLoaderTest<T>::getDetIdForDDDNode( const DDFilteredView& fv )
{
  // perform some consistency checks
  // get the parents and grandparents of this node

  const DDGeoHistory& parents ( fv.geoHistory() ) ;
  const DDGeoHistory::size_type psize ( parents.size() ) ;

  EcalBaseNumber baseNumber ;
  baseNumber.setSize( psize ) ;

  for( unsigned int i=1 ; i<=psize ; ++i )
  {
     baseNumber.addLevel( parents[psize-i].logicalPart().name().name(),
			  parents[psize-i].copyno() ) ;
  }

  return baseNumber.getCopyNumber(0) ;


//  return m_scheme.getUnitID( baseNumber );  
}


#endif
