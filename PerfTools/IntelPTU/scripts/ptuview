#!/usr/bin/env python

##############################################################################
# CGI script to display CSV (comma separated value) files exported by the 
# Intel Performance Tuning Utility (PTU), as html tables
#
# (Some code bits were swiped from igprof-navigator, from Giulio Eulisse,
#  and also included is a bit of javascript for sortable tables available 
#  from the web.)
#
# The expectation is that the script is put into a cgi-bin directory. If
# you prefer it can be renamed w/o problems.
#
# You should export csv files from the PTU source view (any type of profile)
# and also from the corresponding disassembly view of the source, with names
#     somestring_src.csv
#     somestring_asm.csv
# The "somestring" part is up to you. These two files, with those names, 
# should go into a "data" subdirectory of the directory where the cgi 
# script is located. The corresponding URL's will then be:
#
#   http://x.y/z/cgi-bin/ptuview/src/somestring/
#   http://x.y/z/cgi-bin/ptuview/asm/somestring/
#
# The CSV files can also be in some subdirectory of "data", in which
# case the URL's will be
#
#   http://x.y/z/cgi-bin/ptuview/foo/src/somestring/
#   http://x.y/z/cgi-bin/ptuview/foo/asm/somestring/
#
# for files in "data/foo" directory.
#
# There are also cross links between the two using the source code line and
# URL's like:
#
#   http://x.y/z/cgi-bin/ptuview/asm/somestring/78/
#  
# which highlight the particular source code line or the dissassembly which
# corresponds to that source code line.
#
# In addition there is support for displaying the csv exported from the top
# level function-by-function page from the profiles. These should also be
# put in the "data" subdirectory and have names like:
#    somestring_all.csv
# where as before "somestring" is up to you. The URL will then be:
#   http://x.y/z/cgi-bin/ptuview/all/somestring/
#
#
# There is also a summary report, which has some set of events summed
# from the somestring_all.csv file. The URL is
#   http://x,y/z/cgi-bin/ptuview/summary/somestring/
#
#
#  $Id: ptuview,v 1.11 2010/07/25 06:06:25 mkortela Exp $
#
# Peter Elmer, Princeton University
# 24 March, 2010
##############################################################################

from sys import exit
import sys
import os
import csv
import locale
from locale import format
from optparse import OptionParser
import glob
import StringIO
import re
from os.path import join, normpath, exists, basename, isdir, dirname, getsize
debug=False

CSS="""
<style>
body {
  font-family: sans-serif;
}

div {
  padding-bottom: 1em;
}

span {
  padding-right: 1em;
}

table {
  border: 1px solid black;
}

tr.hdr {
  font-size: 70%;
  background-color: #6699ff;  
} 

tr.srcline {
  font-size: 70%;
  background-color: #EEEEEE;  
} 

tr.blockline {
  font-size: 70%;
  border: 1px solid black;
  background-color: #cccccc;  
} 

tr.highlight {
  font-size: 70%;
  border: 1px solid black;
  background-color: #ffddcc;  
} 

    
td {
  font-size: 12px;
  padding: 3px 10px;
  font-family: monospace;
  text-align: ;
  margin: 0px;
  border-width: 0px;
  white-space: nowrap;
}

td.src {
  text-align: left;
  white-space:pre;
}

td.lineadr {
  text-align: left;
  background-color: #cccccc;
}

td.cntr {
  text-align: right;
}

th {
  font-size: 12px;
  padding: 3px 10px;
  margin: 0px;
  border-width: 0px;
}


tbody.parents {
  background-color: #9cc089;
}

tbody.children {
  background-color: #d8f3c9;
}
tbody.mainrow {
  font-weight: bold;
  background-color: #fde8d7;
}

a {
  color: #000000;
}
</style>
"""

JS="""
<script>
/*
  SortTable
  version 2
  7th April 2007
  Stuart Langridge, http://www.kryogenix.org/code/browser/sorttable/
  
  Thanks to many, many people for contributions and suggestions.
  Licenced as X11: http://www.kryogenix.org/code/browser/licence.html
  This basically means: do what you want with it.
*/

 
var stIsIE = /*@cc_on!@*/false;

sorttable = {
  init: function() {
    // quit if this function has already been called
    if (arguments.callee.done) return;
    // flag this function so we don't do the same thing twice
    arguments.callee.done = true;
    // kill the timer
    if (_timer) clearInterval(_timer);
    
    if (!document.createElement || !document.getElementsByTagName) return;
    
    sorttable.DATE_RE = /^(\d\d?)[\/\.-](\d\d?)[\/\.-]((\d\d)?\d\d)$/;
    
    forEach(document.getElementsByTagName('table'), function(table) {
      if (table.className.search(/\\bsortable\\b/) != -1) {
        sorttable.makeSortable(table);
      }
    });
    
  },
  
  makeSortable: function(table) {
    if (table.getElementsByTagName('thead').length == 0) {
      // table doesn't have a tHead. Since it should have, create one and
      // put the first table row in it.
      the = document.createElement('thead');
      the.appendChild(table.rows[0]);
      table.insertBefore(the,table.firstChild);
    }
    // Safari doesn't support table.tHead, sigh
    if (table.tHead == null) table.tHead = table.getElementsByTagName('thead')[0];
    
    if (table.tHead.rows.length != 1) return; // can't cope with two header rows
    
    // Sorttable v1 put rows with a class of "sortbottom" at the bottom (as
    // "total" rows, for example). This is B&R, since what you're supposed
    // to do is put them in a tfoot. So, if there are sortbottom rows,
    // for backwards compatibility, move them to tfoot (creating it if needed).
    sortbottomrows = [];
    for (var i=0; i<table.rows.length; i++) {
      if (table.rows[i].className.search(/\\bsortbottom\\b/) != -1) {
        sortbottomrows[sortbottomrows.length] = table.rows[i];
      }
    }
    if (sortbottomrows) {
      if (table.tFoot == null) {
        // table doesn't have a tfoot. Create one.
        tfo = document.createElement('tfoot');
        table.appendChild(tfo);
      }
      for (var i=0; i<sortbottomrows.length; i++) {
        tfo.appendChild(sortbottomrows[i]);
      }
      delete sortbottomrows;
    }
    
    // work through each column and calculate its type
    headrow = table.tHead.rows[0].cells;
    for (var i=0; i<headrow.length; i++) {
      // manually override the type with a sorttable_type attribute
      if (!headrow[i].className.match(/\\bsorttable_nosort\\b/)) { // skip this col
        mtch = headrow[i].className.match(/\\bsorttable_([a-z0-9]+)\\b/);
        if (mtch) { override = mtch[1]; }
	      if (mtch && typeof sorttable["sort_"+override] == 'function') {
	        headrow[i].sorttable_sortfunction = sorttable["sort_"+override];
	      } else {
	        headrow[i].sorttable_sortfunction = sorttable.guessType(table,i);
	      }
	      // make it clickable to sort
	      headrow[i].sorttable_columnindex = i;
	      headrow[i].sorttable_tbody = table.tBodies[0];
	      dean_addEvent(headrow[i],"click", function(e) {

          if (this.className.search(/\\bsorttable_sorted\\b/) != -1) {
            // if we're already sorted by this column, just 
            // reverse the table, which is quicker
            sorttable.reverse(this.sorttable_tbody);
            this.className = this.className.replace('sorttable_sorted',
                                                    'sorttable_sorted_reverse');
            this.removeChild(document.getElementById('sorttable_sortfwdind'));
            sortrevind = document.createElement('span');
            sortrevind.id = "sorttable_sortrevind";
            sortrevind.innerHTML = stIsIE ? '&nbsp<font face="webdings">5</font>' : '&nbsp;&#x25B4;';
            this.appendChild(sortrevind);
            return;
          }
          if (this.className.search(/\\bsorttable_sorted_reverse\\b/) != -1) {
            // if we're already sorted by this column in reverse, just 
            // re-reverse the table, which is quicker
            sorttable.reverse(this.sorttable_tbody);
            this.className = this.className.replace('sorttable_sorted_reverse',
                                                    'sorttable_sorted');
            this.removeChild(document.getElementById('sorttable_sortrevind'));
            sortfwdind = document.createElement('span');
            sortfwdind.id = "sorttable_sortfwdind";
            sortfwdind.innerHTML = stIsIE ? '&nbsp<font face="webdings">6</font>' : '&nbsp;&#x25BE;';
            this.appendChild(sortfwdind);
            return;
          }
          
          // remove sorttable_sorted classes
          theadrow = this.parentNode;
          forEach(theadrow.childNodes, function(cell) {
            if (cell.nodeType == 1) { // an element
              cell.className = cell.className.replace('sorttable_sorted_reverse','');
              cell.className = cell.className.replace('sorttable_sorted','');
            }
          });
          sortfwdind = document.getElementById('sorttable_sortfwdind');
          if (sortfwdind) { sortfwdind.parentNode.removeChild(sortfwdind); }
          sortrevind = document.getElementById('sorttable_sortrevind');
          if (sortrevind) { sortrevind.parentNode.removeChild(sortrevind); }
          
          this.className += ' sorttable_sorted';
          sortfwdind = document.createElement('span');
          sortfwdind.id = "sorttable_sortfwdind";
          sortfwdind.innerHTML = stIsIE ? '&nbsp<font face="webdings">6</font>' : '&nbsp;&#x25BE;';
          this.appendChild(sortfwdind);

	        // build an array to sort. This is a Schwartzian transform thing,
	        // i.e., we "decorate" each row with the actual sort key,
	        // sort based on the sort keys, and then put the rows back in order
	        // which is a lot faster because you only do getInnerText once per row
	        row_array = [];
	        col = this.sorttable_columnindex;
	        rows = this.sorttable_tbody.rows;
	        for (var j=0; j<rows.length; j++) {
	          row_array[row_array.length] = [sorttable.getInnerText(rows[j].cells[col]), rows[j]];
	        }
	        /* If you want a stable sort, uncomment the following line */
	        //sorttable.shaker_sort(row_array, this.sorttable_sortfunction);
	        /* and comment out this one */
	        row_array.sort(this.sorttable_sortfunction);
	        
	        tb = this.sorttable_tbody;
	        for (var j=0; j<row_array.length; j++) {
	          tb.appendChild(row_array[j][1]);
	        }
	        
	        delete row_array;
	      });
	    }
    }
  },
  
  guessType: function(table, column) {
    // guess the type of a column based on its first non-blank row
    sortfn = sorttable.sort_alpha;
    for (var i=0; i<table.tBodies[0].rows.length; i++) {
      text = sorttable.getInnerText(table.tBodies[0].rows[i].cells[column]);
      if (text != '') {
        if (text.match(/^-?[£$¤]?[\d,.]+%?$/)) {
          return sorttable.sort_numeric;
        }
        // check for a date: dd/mm/yyyy or dd/mm/yy 
        // can have / or . or - as separator
        // can be mm/dd as well
        possdate = text.match(sorttable.DATE_RE)
        if (possdate) {
          // looks like a date
          first = parseInt(possdate[1]);
          second = parseInt(possdate[2]);
          if (first > 12) {
            // definitely dd/mm
            return sorttable.sort_ddmm;
          } else if (second > 12) {
            return sorttable.sort_mmdd;
          } else {
            // looks like a date, but we can't tell which, so assume
            // that it's dd/mm (English imperialism!) and keep looking
            sortfn = sorttable.sort_ddmm;
          }
        }
      }
    }
    return sortfn;
  },
  
  getInnerText: function(node) {
    // gets the text we want to use for sorting for a cell.
    // strips leading and trailing whitespace.
    // this is *not* a generic getInnerText function; it's special to sorttable.
    // for example, you can override the cell text with a customkey attribute.
    // it also gets .value for <input> fields.
    
    hasInputs = (typeof node.getElementsByTagName == 'function') &&
                 node.getElementsByTagName('input').length;
    
    if (node.getAttribute("sorttable_customkey") != null) {
      return node.getAttribute("sorttable_customkey");
    }
    else if (typeof node.textContent != 'undefined' && !hasInputs) {
      return node.textContent.replace(/^\s+|\s+$/g, '');
    }
    else if (typeof node.innerText != 'undefined' && !hasInputs) {
      return node.innerText.replace(/^\s+|\s+$/g, '');
    }
    else if (typeof node.text != 'undefined' && !hasInputs) {
      return node.text.replace(/^\s+|\s+$/g, '');
    }
    else {
      switch (node.nodeType) {
        case 3:
          if (node.nodeName.toLowerCase() == 'input') {
            return node.value.replace(/^\s+|\s+$/g, '');
          }
        case 4:
          return node.nodeValue.replace(/^\s+|\s+$/g, '');
          break;
        case 1:
        case 11:
          var innerText = '';
          for (var i = 0; i < node.childNodes.length; i++) {
            innerText += sorttable.getInnerText(node.childNodes[i]);
          }
          return innerText.replace(/^\s+|\s+$/g, '');
          break;
        default:
          return '';
      }
    }
  },
  
  reverse: function(tbody) {
    // reverse the rows in a tbody
    newrows = [];
    for (var i=0; i<tbody.rows.length; i++) {
      newrows[newrows.length] = tbody.rows[i];
    }
    for (var i=newrows.length-1; i>=0; i--) {
       tbody.appendChild(newrows[i]);
    }
    delete newrows;
  },
  
  /* sort functions
     each sort function takes two parameters, a and b
     you are comparing a[0] and b[0] */
  sort_numeric: function(a,b) {
    aa = parseFloat(a[0].replace(/[^0-9.-]/g,''));
    if (isNaN(aa)) aa = 0;
    bb = parseFloat(b[0].replace(/[^0-9.-]/g,'')); 
    if (isNaN(bb)) bb = 0;
    return aa-bb;
  },
  sort_alpha: function(a,b) {
    if (a[0]==b[0]) return 0;
    if (a[0]<b[0]) return -1;
    return 1;
  },
  sort_ddmm: function(a,b) {
    mtch = a[0].match(sorttable.DATE_RE);
    y = mtch[3]; m = mtch[2]; d = mtch[1];
    if (m.length == 1) m = '0'+m;
    if (d.length == 1) d = '0'+d;
    dt1 = y+m+d;
    mtch = b[0].match(sorttable.DATE_RE);
    y = mtch[3]; m = mtch[2]; d = mtch[1];
    if (m.length == 1) m = '0'+m;
    if (d.length == 1) d = '0'+d;
    dt2 = y+m+d;
    if (dt1==dt2) return 0;
    if (dt1<dt2) return -1;
    return 1;
  },
  sort_mmdd: function(a,b) {
    mtch = a[0].match(sorttable.DATE_RE);
    y = mtch[3]; d = mtch[2]; m = mtch[1];
    if (m.length == 1) m = '0'+m;
    if (d.length == 1) d = '0'+d;
    dt1 = y+m+d;
    mtch = b[0].match(sorttable.DATE_RE);
    y = mtch[3]; d = mtch[2]; m = mtch[1];
    if (m.length == 1) m = '0'+m;
    if (d.length == 1) d = '0'+d;
    dt2 = y+m+d;
    if (dt1==dt2) return 0;
    if (dt1<dt2) return -1;
    return 1;
  },
  
  shaker_sort: function(list, comp_func) {
    // A stable sort function to allow multi-level sorting of data
    // see: http://en.wikipedia.org/wiki/Cocktail_sort
    // thanks to Joseph Nahmias
    var b = 0;
    var t = list.length - 1;
    var swap = true;

    while(swap) {
        swap = false;
        for(var i = b; i < t; ++i) {
            if ( comp_func(list[i], list[i+1]) > 0 ) {
                var q = list[i]; list[i] = list[i+1]; list[i+1] = q;
                swap = true;
            }
        } // for
        t--;

        if (!swap) break;

        for(var i = t; i > b; --i) {
            if ( comp_func(list[i], list[i-1]) < 0 ) {
                var q = list[i]; list[i] = list[i-1]; list[i-1] = q;
                swap = true;
            }
        } // for
        b++;

    } // while(swap)
  }  
}

/* ******************************************************************
   Supporting functions: bundled here to avoid depending on a library
   ****************************************************************** */

// Dean Edwards/Matthias Miller/John Resig

/* for Mozilla/Opera9 */
if (document.addEventListener) {
    document.addEventListener("DOMContentLoaded", sorttable.init, false);
}

/* for Internet Explorer */
/*@cc_on @*/
/*@if (@_win32)
    document.write("<script id=__ie_onload defer src=javascript:void(0)><\/script>");
    var script = document.getElementById("__ie_onload");
    script.onreadystatechange = function() {
        if (this.readyState == "complete") {
            sorttable.init(); // call the onload handler
        }
    };
/*@end @*/

/* for Safari */
if (/WebKit/i.test(navigator.userAgent)) { // sniff
    var _timer = setInterval(function() {
        if (/loaded|complete/.test(document.readyState)) {
            sorttable.init(); // call the onload handler
        }
    }, 10);
}

/* for other browsers */
window.onload = sorttable.init;

// written by Dean Edwards, 2005
// with input from Tino Zijdel, Matthias Miller, Diego Perini

// http://dean.edwards.name/weblog/2005/10/add-event/

function dean_addEvent(element, type, handler) {
	if (element.addEventListener) {
		element.addEventListener(type, handler, false);
	} else {
		// assign each event handler a unique ID
		if (!handler.$$guid) handler.$$guid = dean_addEvent.guid++;
		// create a hash table of event types for the element
		if (!element.events) element.events = {};
		// create a hash table of event handlers for each element/event pair
		var handlers = element.events[type];
		if (!handlers) {
			handlers = element.events[type] = {};
			// store the existing event handler (if there is one)
			if (element["on" + type]) {
				handlers[0] = element["on" + type];
			}
		}
		// store the event handler in the hash table
		handlers[handler.$$guid] = handler;
		// assign a global event handler to do all the work
		element["on" + type] = handleEvent;
	}
};
// a counter used to create unique IDs
dean_addEvent.guid = 1;

function removeEvent(element, type, handler) {
	if (element.removeEventListener) {
		element.removeEventListener(type, handler, false);
	} else {
		// delete the event handler from the hash table
		if (element.events && element.events[type]) {
			delete element.events[type][handler.$$guid];
		}
	}
};

function handleEvent(event) {
	var returnValue = true;
	// grab the event object (IE uses a global event object)
	event = event || fixEvent(((this.ownerDocument || this.document || this).parentWindow || window).event);
	// get a reference to the hash table of event handlers
	var handlers = this.events[event.type];
	// execute each event handler
	for (var i in handlers) {
		this.$$handleEvent = handlers[i];
		if (this.$$handleEvent(event) === false) {
			returnValue = false;
		}
	}
	return returnValue;
};

function fixEvent(event) {
	// add W3C standard event methods
	event.preventDefault = fixEvent.preventDefault;
	event.stopPropagation = fixEvent.stopPropagation;
	return event;
};
fixEvent.preventDefault = function() {
	this.returnValue = false;
};
fixEvent.stopPropagation = function() {
  this.cancelBubble = true;
}

// Dean's forEach: http://dean.edwards.name/base/forEach.js
/*
	forEach, version 1.0
	Copyright 2006, Dean Edwards
	License: http://www.opensource.org/licenses/mit-license.php
*/

// array-like enumeration
if (!Array.forEach) { // mozilla already supports this
	Array.forEach = function(array, block, context) {
		for (var i = 0; i < array.length; i++) {
			block.call(context, array[i], i, array);
		}
	};
}

// generic enumeration
Function.prototype.forEach = function(object, block, context) {
	for (var key in object) {
		if (typeof this.prototype[key] == "undefined") {
			block.call(context, object[key], key, object);
		}
	}
};

// character enumeration
String.forEach = function(string, block, context) {
	Array.forEach(string.split(""), function(chr, index) {
		block.call(context, chr, index, string);
	});
};

// globally resolve forEach enumeration
var forEach = function(object, block, context) {
	if (object) {
		var resolve = Object; // default
		if (object instanceof Function) {
			// functions have a "length" property
			resolve = Function;
		} else if (object.forEach instanceof Function) {
			// the object implements a custom forEach method so use that
			object.forEach(block, context);
			return;
		} else if (typeof object == "string") {
			// the object is a string
			resolve = String;
		} else if (typeof object.length == "number") {
			// the object is array-like
			resolve = Array;
		}
		resolve.forEach(object, block, context);
	}
};

</script>
"""

# Generate the basic block report, which at the moment consists from
# showing the png file as it is (if one exists)
def getBasicBlockReport(mycsvfile, out):
    fname = mycsvfile.replace(".csv", ".png")
    if not os.path.exists(fname):
      out.write("<h2>File not found</h2>\n")
      return "html"
    
    file = open(mycsvfile.replace(".csv", ".png"), "rb")
    out.write(file.read())
    return "png"

# Class for representing a single event for summary report. The field
# index is the index in a row which contains the value of the event
# (this is read by the addCount() method). The counts over all rows
# are summed. The event may contain an associated penalty (number of
# cycles spent per count). The penalty is accessible for the cost
# expressions.
#
# The event might not exist in the csv file, in which case the field
# index should never be set and the isValid() methods returns false.
#
# A SummaryCost object can be assigned to an event object. If this is
# done, the value and the description of the cost object are shown in
# the same row as the event in the report. Note that the cost value is
# shown only if the cost object is valid (i.e. all the variables in
# the cost expression are valid).
class SummaryEvent:
    def __init__(self, name, penalty=None):
        self.name = name
        self.counts = 0.0
        self.fieldIndex = -1
        self.penalty = penalty
        self.cost = None

    def setIndex(self, i):
        self.fieldIndex = i

    def setCost(self, cost):
        self.cost = cost

    def addCount(self, row, out):
        if self.isValid():
            self.counts += float(row[self.fieldIndex])

    def getCounts(self):
        return self.counts

    def getName(self):
        return self.name

    def isValid(self):
        return self.fieldIndex >= 0

    def asRow(self):
        cost = ""
        desc = ""
        if self.cost != None and self.cost.isValid():
            cost = self.cost.getValue()
            desc = self.cost.getDescription()
        
        return '<td>%s</td><td class="cntr">%.0f</td><td class="cntr">%s</td><td class="cntr">%s</td><td>%s</td>' % (self.name, self.counts, self.getPenaltyStr(), cost, desc)

    def getPenaltyStr(self):
        if self.penalty == None:
            return ""
        else:
            return str(self.penalty)

    def getPenaltyValue(self):
        if self.penalty == None:
            return 0
        else:
            return self.penalty
        
# Represents a group of summary events. A group has a common
# background color and a common leftmost cell containing the group
# name in the table.
class SummaryEventGroup:
    def __init__(self, name, color="white", events=[]):
        self.name = name
        self.color = color
        self.events = []
        for x in events:
            if isinstance(x, SummaryEvent):
                self.events.append(x)
            else:
                self.events.append(SummaryEvent(x))

    def getEvents(self):
        return self.events

    def getValidEvents(self):
        ret = []
        for ev in self.events:
            if ev.isValid():
                ret.append(ev)
        return ret

    def getName(self):
        return self.name

    def getStyle(self):
        return 'style="background-color: %s"' % self.color

# Represents a quantity which can be calculated from the event counts
# or from other cost objects (or in principle anything the evaluator
# supports). The value of the cost is shown in the "Cost" column of
# the report, and the description is shown in the "Description"
# column. The row in the report where the cost values are shown is the
# event indicated by setPlace()
#
# Valid cost expressions are any python expression where the event
# counts and cost objects are accessed by ${name}. In addition the
# penalty associated to an event can be accessed by ${event:penalty}.
#
# Note: a cost expression can use the value of another cost expression
# which has been added *before*. The name of the variable is the name
# of the cost object. (see SummaryEventAll below)
class SummaryCost:
    def __init__(self, expr, format="%.2f %%", description=""):
        self.expr = expr
        self.format = format
        self.description = description
        self.value = None
        self.status = False
        self.place = None

    def evaluate(self, evaluator):
        (self.value, self.status) = evaluator.evaluate(self.expr)

    def setPlace(self, place):
        self.place = place

    def getPlace(self):
        return self.place

    def isValid(self):
        return self.status

    def getValue(self):
        if isinstance(self.value, str):
            return self.value
        else:
            return self.format % self.value

    def getValueRaw(self):
        return self.value

    def getDescription(self):
        return self.description

# The main container of all summary events, event groups and
# costs. Has dictionaries of events and costs, they are used for
# finding the values of events/costs when the cost expressions are
# evaluated.
#
# The expressions are evaluated with the eval() function, which is a
# bit quick&dirty solution. The result of evaluation is considered to
# be valid if only if all the events/costs in the expression were
# valid.
#
# A cost is assigned to a specified event if and only if the cost is
# valid. If there are multiple valid costs associated to a single
# event, the one added last is assigned to the event.
#
# Note: a cost expression can use the value of another cost expression
# which has been added *before*. The name of the variable is the name
# of the cost object.
class SummaryEventAll:
    def __init__(self, groups):
        self.groups = groups
        self.events = []
        for g in groups:
            self.events.extend(g.getEvents())

        self.eventDict = {}
        for e in self.events:
            self.eventDict[e.getName()] = e

        self.costs = []
        self.costDict = {}

    def addCost(self, name, place, cost):
        self.costs.append(cost)
        self.costDict[name] = cost
        cost.setPlace(place)

    def computeCosts(self):
        for c in self.costs:
            c.evaluate(self)
            if c.isValid() and self.eventDict.has_key(c.getPlace()):
                self.eventDict[c.getPlace()].setCost(c)

    def getEvents(self):
        return self.events

    def getGroups(self):
        return self.groups

    def evaluate(self, s):
        var_re = re.compile("\${(?P<var>\S+?)}")

        m = var_re.search(s)
        while m:
            var = m.group("var")

            tmp = var.split(":")
            var = tmp[0]
            meth = None
            if len(tmp) >= 2:
                meth = tmp[1]

            val = 0
            if self.eventDict.has_key(var):
                if not self.eventDict[var].isValid():
                    return (None, False)
                
                if meth == "penalty":
                    val = self.eventDict[var].getPenaltyValue()
                else:    
                    val = self.eventDict[var].getCounts()
            elif self.costDict.has_key(var):
                if not self.costDict[var].isValid():
                    return (None, False)
                
                val = self.costDict[var].getValueRaw()
            else:    
                return ("variable '%s' not found" % var, False)

            s = s[:m.start()] + str(val) + s[m.end():]
            
            m = var_re.search(s)

        return (eval(s), True)

def getSummaryReport(mycsvfile, out, reader):
    # Specify the event groups and events with possible penalties
    groups = SummaryEventAll([SummaryEventGroup("General and uops", color="#fffc98",
                                                events= ["CPU_CLK_UNHALTED.CORE", # Core2
                                                         "CPU_CLK_UNHALTED.THREAD", # Nehalem
                                                         "CPU_CLK_UNHALTED.THREAD max(lCPU)", # Nehalem 
                                                         "INST_RETIRED.ANY",
                                                         "UOPS_RETIRED.RETIRE_SLOTS",
                                                         "UOPS_RETIRED.STALL_CYCLES",
                                                         "UOPS_RETIRED.ANY",
                                                         "UOPS_ISSUED.CORE_STALL_CYCLES",
                                                         "UOPS_ISSUED.STALL_CYCLES",
                                                         "RESOURCE_STALLS.ANY",
                                                         "INST_QUEUE_WRITE_CYCLES",
                                                         SummaryEvent("UOPS_DECODED.STALL_CYCLES", penalty=1)]),
                              SummaryEventGroup("Numeric", color="#c9a7cc",
                                                events=[SummaryEvent("ARITH.CYCLES_DIV_BUSY", penalty=1),
                                                        SummaryEvent("UOPS_DECODED.MS_CYCLES_ACTIVE", penalty=1)]),
                              SummaryEventGroup("Instruction fetch", color="#ffb38f",
                                                events=[SummaryEvent("L2_RQSTS.IFETCH_HIT", penalty=6),
                                                        "L2_RQSTS.IFETCH_MISS",
                                                        SummaryEvent("OFFCORE_RESPONSE_0.DEMAND_IFETCH.LOCAL_CACHE", penalty=35),
                                                        SummaryEvent("OFFCORE_RESPONSE_0.DEMAND_IFETCH.LOCAL_DRAM", penalty=200),
                                                        SummaryEvent("OFFCORE_RESPONSE_0.DEMAND_IFETCH.REMOTE_DRAM", penalty=350),
                                                        SummaryEvent("ITLB_MISSES.ANY", penalty=35),
                                                        "ITLB_MISSES.WALK_COMPLETED"]),
                              SummaryEventGroup("LOAD", color="#beffde",
                                                events=[SummaryEvent("MEM_LOAD_RETIRED.L2_HIT", penalty=6),
                                                        SummaryEvent("MEM_LOAD_RETIRED.LLC_UNSHARED_HIT", penalty=35),
                                                        SummaryEvent("MEM_UNCORE_RETIRED.LOCAL_DRAM", penalty=200),
                                                        SummaryEvent("MEM_UNCORE_RETIRED.REMOTE_DRAM", penalty=350),
                                                        SummaryEvent("DTLB_MISSES.ANY", penalty=35)]),
                              SummaryEventGroup("Branches", color="#ffb5de",
                                                events=["BR_INST_RETIRED.ALL_BRANCHES",
                                                        "BR_INST_EXEC.DIRECT_NEAR_CALL",
                                                        "BR_INST_EXEC.INDIRECT_NEAR_CALL",
                                                        "BR_INST_EXEC.INDIRECT_NON_CALL",
                                                        "BR_INST_EXEC.NON_CALLS",
                                                        "BR_INST_RETIRED.NEAR_CALL",
                                                        "BR_INST_EXEC.ANY"]),
                              SummaryEventGroup("Other", color="#f3f3f3",
                                                events=["INST_DECODED.DEC0",
                                                        "INST_QUEUE_WRITES",
                                                        "PARTIAL_ADDRESS_ALIAS",
                                                        "MACHINE_CLEARS.MEM_ORDER",
                                                        "MEM_LOAD_RETIRED.LLC_MISS",
                                                        "ITLB_MISS_RETIRED",
                                        "OFFCORE_RESPONSE_0.DATA_IN.LOCAL_DRAM",
                                                        "MACHINE_CLEARS.CYCLES",
                                                        "OFFCORE_RESPONSE_0.DATA_IN.LOCAL_CACHE"])])
    # Specify cost expressions
    cycles = "CPU_CLK_UNHALTED.THREAD"
    event = "INST_RETIRED.ANY"
    groups.addCost("cpi_nhm", event, SummaryCost("${%s}/${%s}" % (cycles, event), description="CPI", format="%.2f"))
    groups.addCost("cpi_core2", event, SummaryCost("${CPU_CLK_UNHALTED.CORE}/${%s}" % event, description="CPI", format="%.2f"))

    event = "UOPS_RETIRED.STALL_CYCLES"
    groups.addCost("ret_stall", event, SummaryCost("${%s}/${%s}*100" % (event, cycles),
                                                   description="of cycles with retirement stalls"))

    event = "RESOURCE_STALLS.ANY"
    groups.addCost("backend_starvation", event, SummaryCost("(${UOPS_ISSUED.STALL_CYCLES}-${%s})/${%s}*100" % (event, cycles),
                                                            description="of cycles with backend instruction starvation"))


    event = "UOPS_DECODED.STALL_CYCLES"
    groups.addCost("frontend_decoder_inactive", event, SummaryCost("${%s}*${%s:penalty} / ${%s} * 100" % (event, event, cycles),
                                                                   description="of cycles when the frontend decoder is inactive (compare to instruction starvation)"))
    event = "ARITH.CYCLES_DIV_BUSY"
    groups.addCost("div_sqrt", event, SummaryCost("${%s}*${%s:penalty} / ${%s} * 100" % (event, event, cycles),
                                                  description="of cycles spent in divides and SQRTs"))
    event = "UOPS_DECODED.MS_CYCLES_ACTIVE"
    groups.addCost("fpe", event, SummaryCost("${%s}*${%s:penalty} / ${%s} * 100" % (event, event, cycles),
                                             description="of cycles executing floating point exceptions"))
                               
    event = "L2_RQSTS.IFETCH_HIT"
    groups.addCost("l2_ifetch_hit", event, SummaryCost("${%s}*${%s:penalty} / ${%s} * 100" % (event, event, cycles),
                                                       description="of cycles waiting for an IFETCH from L2 (subject to overcounting)"))

    event = "OFFCORE_RESPONSE_0.DEMAND_IFETCH.LOCAL_CACHE"
    groups.addCost("offcore_llc", event, SummaryCost("${%s}*${%s:penalty} / ${%s} * 100" % (event, event, cycles),
                                                     description="of cycles waiting for an IFETCH from L3 (LLC) (subject to overcounting)"))

    event = "OFFCORE_RESPONSE_0.DEMAND_IFETCH.LOCAL_DRAM"
    groups.addCost("offcore_ld", event, SummaryCost("${%s}*${%s:penalty} / ${%s} * 100" % (event, event, cycles),
                                                    description="of cycles waiting for an IFETCH from LOCAL DRAM"))

    event = "OFFCORE_RESPONSE_0.DEMAND_IFETCH.REMOTE_DRAM"
    groups.addCost("offcore_rd", event, SummaryCost("${%s}*${%s:penalty} / ${%s} * 100" % (event, event, cycles),
                                                    description="of cycles waiting for an IFETCH from REMOTE DRAM"))

    event = "ITLB_MISSES.ANY"
    groups.addCost("itlb_miss", event, SummaryCost("${%s}*${%s:penalty} / ${%s} * 100" % (event, event, cycles),
                                                   description="of cycles waiting for ITLB miss handling"))

    groups.addCost("any_ifetch", "UOPS_ISSUED.STALL_CYCLES", SummaryCost("${l2_ifetch_hit}+${offcore_llc}+${offcore_ld}+${offcore_rd}+${itlb_miss}",
                                                                         description="of cycles waiting for any IFETCH miss handling (subject to overcounting"))


    event = "MEM_LOAD_RETIRED.L2_HIT"
    groups.addCost("load_l2_hit", event, SummaryCost("${%s}*${%s:penalty} / ${%s} * 100" % (event, event, cycles),
                                                     description="of cycles waiting for a LOAD driven miss that hits L2"))

    event = "MEM_LOAD_RETIRED.LLC_UNSHARED_HIT"
    groups.addCost("load_llc_hit", event, SummaryCost("${%s}*${%s:penalty} / ${%s} * 100" % (event, event, cycles),
                                                     description="of cycles waiting for a LOAD driven miss that hits L3 (LLC)"))

    event = "MEM_UNCORE_RETIRED.LOCAL_DRAM"
    groups.addCost("load_ld", event, SummaryCost("${%s}*${%s:penalty} / ${%s} * 100" % (event, event, cycles),
                                                 description="of cycles waiting for a LOAD driven miss that hits LOCAL DRAM"))

    event = "MEM_UNCORE_RETIRED.REMOTE_DRAM"
    groups.addCost("load_rd", event, SummaryCost("${%s}*${%s:penalty} / ${%s} * 100" % (event, event, cycles),
                                                 description="of cycles waiting for a LOAD driven miss that hits REMOTE DRAM"))

    event = "DTLB_MISSES.ANY"
    groups.addCost("dtlb_miss", event, SummaryCost("${%s}*${%s:penalty} / ${%s} * 100" % (event, event, cycles),
                                                   description="of cycles waiting for DTLB miss handling"))

    event = "BR_INST_RETIRED.ALL_BRANCHES"
    branch_all = event
    groups.addCost("branch_p_call", event, SummaryCost("${%s} / ${BR_INST_RETIRED.NEAR_CALL}" % event,
                                                   description="branches per call", format="%.1f"))

    event = "BR_INST_EXEC.INDIRECT_NEAR_CALL"
    groups.addCost("branch_indirect_near", event, SummaryCost("${%s} / ${%s} * 100" % (event, branch_all),
                                                   description="of all branches that are indirect near calls"))

    event = "BR_INST_EXEC.INDIRECT_NON_CALL"
    groups.addCost("branch_indirect_non", event, SummaryCost("${%s} / ${%s} * 100" % (event, branch_all),
                                                             description="of all branches that are indirect non calls"))

    event = "BR_INST_RETIRED.NEAR_CALL"
    groups.addCost("instr_per_call", event, SummaryCost("${INST_RETIRED.ANY} / ${%s}" % event,
                                                        description="instructions per call", format="%.2f"))

    event = "BR_MISP_EXEC.ANY"
    groups.addCost("branch_mispred", event, SummaryCost("${%s} / ${%s} * 100" % (event, branch_all),
                                                        description="of all branches were mispredicted"))

    # Read the CSV file
    rownum = 0
    moduleIndex = -1
    vmlinuxRemoved = False
    for row in reader:
        # header
        if rownum == 0:
            header = row

            for ev in groups.getEvents():
                for ifield, field in enumerate(header):
                    if field == ev.getName():
                        ev.setIndex(ifield)
                    elif field == "Module":
                        moduleIndex = ifield
        else:
            # skip the idle process
            if moduleIndex >= 0 and row[moduleIndex] == "vmlinux":
                vmlinuxRemoved = True
                continue
                
            for ev in groups.getEvents():
                ev.addCount(row, out)
        rownum += 1

    # Compute values of the cost expressions, valid costs are
    # associated to the specified events.
    groups.computeCosts()    

    # Present the accumulated data as a table
    if vmlinuxRemoved:
        out.write("<p>Note: system idle process (vmlinux) has been removed from the numbers below<p>\n")
    out.write("<table>\n")
    out.write('<thead><tr class="hdr"><th>Group</th><th>Event</th><th>Counts</th><th>Penalty</th><th>Cost</th><th>Description</th></thead>\n')
    out.write("<tbody>\n")
    for g in groups.getGroups():
        evs = g.getValidEvents()
        if len(evs) == 0:
            continue

        style = g.getStyle()

        out.write('<tr %s><td rowspan="%d">%s</td>%s</tr>\n' % (style, len(evs), g.getName(), evs[0].asRow()))
        for ev in evs[1:]:
            out.write('<tr %s>%s</tr>\n' % (style, ev.asRow()))
    out.write("</tbody>\n")
    out.write("</table>\n")

    return "html"

# Preferred order for source annotation
# xxxx,"INST_RETIRED.ANY","CPU_CLK_UNHALTED.CORE","Line", "Source"
#  "CPU_CLK_UNHALTED.CORE max(lCPU)" should be suppressed if there
#
# Preferred order for disassembly annotation
# xxxx,"INST_RETIRED.ANY","CPU_CLK_UNHALTED.CORE","Address","Line","Assembly"
#  "CPU_CLK_UNHALTED.CORE max(lCPU)" should be suppressed if there

def getcsvtable(mycsvfile,cgiscript,proftype,profname,hlline,out):
  # Here the preferred order is given from right to left for simplicity,
  # since anything "extra" we will eventually want on the left of these things.
  # since the real constraint here is that the last thing should be the
  # source lines, since they can be of arbitrary length.

  srcorder = ["RVA","Module","Function","Source","Assembly","Line","Address","CPU_CLK_UNHALTED.CORE","INST_RETIRED.ANY"]
  srcclass = ["src","src","src","src","src","lineadr","lineadr","cntr","cntr"]
  srcclassother = "cntr"
  srcsuppress = ["FirstLine", "CPU_CLK_UNHALTED.CORE max(lCPU)"]

  if proftype == "bbl":
    return getBasicBlockReport(mycsvfile, out)

  ifile  = open(mycsvfile, "rb")
  reader = csv.reader(ifile)

  block_re = re.compile("Block\s+(?P<num>\d+)")

  # Add cross links between summary and all report
  # Add cross links between asm and src views, and also a link to the
  # basic block graph, if one exists
  if proftype == "all":
      out.write("<div>\n")
      out.write('<span><a href="%s/summary/%s">Summary report</a></span>\n' % (cgiscript, profname))
      out.write("</div>\n")
  elif proftype == "summary":
      out.write("<div>\n")
      out.write('<span><a href="%s/all/%s">Full report</a></span>\n' % (cgiscript, profname))
      out.write("</div>\n")

      # Note that building the summary report is done in a separate function
      return getSummaryReport(mycsvfile, out, reader)
  elif proftype == "src"or proftype == "asm":
      out.write("<div>\n")
      url = cgiscript
      desc = ""
      if proftype == "src":
          url += '/asm/'
          desc = "Assembly view"
      elif proftype == "asm":
          url += '/src/'
          desc = "Source view"
      url += profname   

      out.write('<span><a href="%s">%s</a></span>\n' % (url, desc))
      file = os.path.join(dirname(mycsvfile), profname+"_bbl.png")
      if os.path.exists(file):
          out.write('<span><a href="%s/bbl/%s">Basic block graph</span></a>\n' % (cgiscript, profname))

      out.write("</div>\n")

  # Now we're ready to build the all/src/asm report
  rownum = 0
  fieldordered = []
  classordered = []
  titleordered = []
  hdrmap = {} 
  for row in reader:
    # The header row gets a different css class
    # Figure out which column has the "Source", that should be
    # at the end since the lines can be arbitrarily long
    if rownum == 0:
        header = row

        # In "all" report we don't want the Source column to be shown, if there is a function column
        if proftype == "all" and "Function" in header:
          i = srcorder.index("Source")
          del srcorder[i]
          del srcclass[i]
          srcsuppress.append("Source")

        
        # Figure out which fields are in which location and determine
        # the order of fields needed to meet the preferred order

        linelength = len(header)
        blackball = []
        for iii in range(0,linelength):
          blackball.append(0)

        # First look for all fields explicitly listed as having a preferred
        # order. Ignore the others for now.
        for ifield, afield in enumerate(srcorder):
          thefield = -1
          theclass = ""
          thetitle = ""
          for jfield, bfield in enumerate(header):
            if (afield == bfield):
              thefield = jfield 
              theclass = srcclass[ifield] 
              thetitle = bfield 
              # Deal also with a special case
          if thefield != -1:
              fieldordered.append(thefield)
              classordered.append(theclass)
              titleordered.append(thetitle)
              blackball[thefield]=1

        # Now look through the others, dropping those which were specified
        # as part of the preferred order and those in the explicit suppression
        # list
        for afield in srcsuppress: 
          for jfield, bfield in enumerate(header):
            if afield == bfield:
              blackball[jfield]=1
        for kfield, cfield in enumerate(blackball):
          if cfield == 0:
            fieldordered.append(kfield)
            classordered.append(srcclassother)
            titleordered.append(header[kfield]) 

        # Now reverse the order (to the left-to-right one)
        fieldordered.reverse()
        classordered.reverse()
        titleordered.reverse()

        # Retain also a map of the header fields to indices (assuming no 
        # duplications!)
        for jfield, bfield in enumerate(header):
          hdrmap[bfield] = jfield

        # Now actually print out the header line, in the correct order,
        # and without any fields which were to be suppressed
        out.write("<table class=\"sortable\">\n")
        out.write("<thead><tr class=hdr>\n")
        linelength = len(header)
        for iii in fieldordered:
          out.write("<th>%s</th>\n" % header[iii])
        out.write("</tr></thead>\n")
        out.write("<tbody>\n")
    else:
        colnum = 0

        theclass="srcline"
        # Deal with special "Block" lines in asm profile
        if "Address" in hdrmap:
          addressfield=hdrmap["Address"]
          if "Block" in row[addressfield]:
            theclass = "blockline"
        # Deal also with lines to be highlighted (takes precedence)
        if "Line" in hdrmap:
          specialfield=hdrmap["Line"]
          if row[specialfield] == hlline:
            theclass = "highlight"
        out.write("<tr class=%s>\n" % theclass )
        url1 = "<a href=\"" + cgiscript

        urlbbl = ""
        if proftype == "asm":
          file = os.path.join(dirname(mycsvfile), profname+"_bbl.png")
          if os.path.exists(file):
            urlbbl = url1
            urlbbl += "/bbl/"

        if (proftype == "src"):
          url1 += "/asm/"
        else: #(proftype == "asm")
          url1 += "/src/"
          
        url3 = "</a>"
        for iii,jjj in enumerate(fieldordered):
          rowtxt=row[jjj]
          rowtxt=rowtxt.replace(">","&gt;")
          rowtxt=rowtxt.replace("<","&lt;")
          if (titleordered[iii] == "Line"):
            url2 = url1 + profname + "/" + row[jjj] + "/#" + row[jjj] + "\">"
            out.write("<td class=%s><a name=\"%s\">%s%s%s</a></td>\n" % (classordered[iii],row[jjj],url2,rowtxt,url3))
          elif (titleordered[iii] == "Function"):
            funcnum = rownum-1
            reportfile = os.path.join(dirname(mycsvfile), "%d_src.csv" % funcnum)
            if os.path.exists(reportfile):
              lineno = ""
              if hdrmap.has_key("FirstLine"):
                lineno = row[hdrmap["FirstLine"]]
                if lineno != "":
                  no = int(lineno)
                  if no > 10:
                    no -= 5
                  lineno = "/#%d" % no
              url2 = url1 + str(funcnum) + ("%s\">" % lineno)
              out.write("<td class=%s>%s%s%s</td>\n" % (classordered[iii],url2,rowtxt,url3))
            else:
              out.write("<td class=%s>%s</td>\n" % (classordered[iii],rowtxt))
          elif titleordered[iii] == "Address":
            out.write("<td class=%s>" % classordered[iii])
            m = block_re.search(rowtxt)
            if m and len(urlbbl) > 0:
              url2 = urlbbl + profname + '">'
              anchor = "block"+m.group("num")
              out.write('<a name="%s">%s%s%s</a>' % (anchor,url2,rowtxt,url3))
            else:
              out.write("%s" % rowtxt)
            out.write("</td>\n")
          elif titleordered[iii] == "Assembly":
            m = block_re.search(rowtxt)
            if m:
              rowtxt = block_re.sub('<a href="#block%s">\g<0></a>'%m.group("num"), rowtxt)
              out.write("<td class=%s>%s</td>\n" % (classordered[iii],rowtxt))
            else:  
              out.write("<td class=%s>%s</td>\n" % (classordered[iii],rowtxt))
          else:
            # hack to circumvent the inability of sorttable to sort the values like 1E10
            if rowtxt.find("E") >= 0 or rowtxt.find("e") >= 0:
              try:
                sortkey = float(rowtxt)
                out.write('<td class=%s sorttable_customkey="%f">%s</td>\n' % (classordered[iii], sortkey, rowtxt))
              except ValueError:
                out.write("<td class=%s>%s</td>\n" % (classordered[iii],rowtxt))
            else:
              out.write("<td class=%s>%s</td>\n" % (classordered[iii],rowtxt))
        out.write("</tr>\n")
            
    rownum += 1
  ifile.close()
  out.write("</tbody>\n")
  out.write("</table>\n")
  return "html"


def findReportType(args):
  for t in ["src", "asm", "all", "bbl", "summary"]:
    try:
      i = args.index(t)
      return (i, t)
    except ValueError:
      pass

  return (None, None)  

def printHtmlHeader(out):
  out.write("Content-Type: text/html\n\n")
  out.write("<html>\n")
  out.write(CSS)
  out.write(JS)
  out.write("<body>\n")

def printHtmlFooter(out):
  out.write("</body></html>")

def printPngHeader(out):
  out.write("Content-Type: image/png\n\n")

def printError(out):
  printHtmlHeader(out)
  out.write("<h1>Invalid URL:</h1>\n")
  printHtmlFooter(out)

def buildReply(out):
  if not "PATH_INFO" in os.environ or not "SCRIPT_FILENAME" in os.environ:
    printHtmlHeader(out)
    out.write("<h1>No vars:</h1>\n")
    printHtmlFooter(out)
  else:
    relPath = os.environ["PATH_INFO"].replace(os.environ["SCRIPT_FILENAME"], "").lstrip("/")
    # Tokenize the relPath. Ignore anything after the 3rd field.
    # The first field must be "src" or "asm" at the moment.
    # The second field is the "name" of the profile
    # The thrid field flags line numbers to highlight
    relargs = relPath.split('/')

    (index, proftype) = findReportType(relargs)
    
    if index != None and (len(relargs) >= index+2) and (relargs[index+1] != ""):
      profname = relargs[index+1] 
      dataPath = join(os.getcwd(), "data")
      mypath = normpath(dataPath)
      subdir = ""
      if index > 0:
        subdir = normpath("/".join(relargs[0:index]))
        mypath = os.path.join(dataPath, subdir)
        if mypath.find(dataPath) < 0:
          printError(out)
          return

      mycsvfile = mypath + "/" + profname + "_"
      if proftype == "summary":
          mycsvfile += "all"
      else:
          mycsvfile += proftype
      mycsvfile += ".csv"    
      cgiscript = os.environ["SCRIPT_FILENAME"].replace(os.environ["DOCUMENT_ROOT"],"")
      if cgiscript[0] != "/":
        cgiscript = "/"+cgiscript
      if len(subdir) > 0:
        cgiscript += "/" + subdir
      
      hlline = -1
      if (len(relargs) >= index+3):
        hlline = relargs[index+2]

      output = StringIO.StringIO()  
      type = getcsvtable(mycsvfile,cgiscript,proftype,profname,hlline,output)
      if type == "html":
        printHtmlHeader(out)
        out.write("<h1>%s profile - %s</h1>\n" % (proftype,profname))
        out.write(output.getvalue())
        printHtmlFooter(out) 
      elif type == "png":
        printPngHeader(out)
        out.write(output.getvalue())
      else:
        printError(out)

      output.close()
    else:
      printError(out)

###########################################################################

if __name__ == "__main__":
  # Uncomment in case of debugging needs
  if debug:
    cgitb.enable()
  if "LC_ALL" in os.environ:
    locale.setlocale(locale.LC_NUMERIC, os.environ["LC_ALL"])
  else:
    locale.setlocale(locale.LC_NUMERIC, "en_US.UTF-8")

  parser = OptionParser(usage="igprof-navigator [file [options]] ")
  parser.add_option("--port", "-p", dest="port", default=8080, type="int")
  parser.add_option("--timeout", "-t", dest="timeout", default=60*15, type="int")
  opts, args = parser.parse_args()

  buildReply(sys.stdout)

