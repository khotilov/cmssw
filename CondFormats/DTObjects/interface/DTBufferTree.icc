/*
 *  See header file for a description of this class.
 *
 *  $Date: 2006/02/28 17:28:55 $
 *  $Revision: 1.1 $
 *  \author Paolo Ronchese INFN Padova
 *
 */

//----------------------
// This Class' Header --
//----------------------
#include "CondFormats/DTObjects/interface/DTBufferTree.h"

//-------------------------------
// Collaborating Class Headers --
//-------------------------------


//---------------
// C++ Headers --
//---------------

//-------------------
// Initializations --
//-------------------
template <class Key, class Content>
Content DTBufferTree<Key,Content>::defaultContent;

//----------------
// Constructors --
//----------------
template <class Key, class Content>
DTBufferTree<Key,Content>::DTBufferTree():
 bufferContent( defaultContent ) {
}

//--------------
// Destructor --
//--------------
template <class Key, class Content>
DTBufferTree<Key,Content>::~DTBufferTree() {
  map_iter iter = bufferMap.begin();
  map_iter iend = bufferMap.end();
  while ( iter != iend ) delete (iter++)->second;
}

//--------------
// Operations --
//--------------
template <class Key, class Content>
int DTBufferTree<Key,Content>::insert( ElementKey fKey,
                                       ElementKey lKey,
                                       const Content& cont ) {
  int status = 0;
  if ( fKey == lKey ) {
    bufferContent = cont;
    status = 1;
  }
  else {
    map_iter iter = bufferMap.find( *fKey );
    if ( iter == bufferMap.end() ) {
      map_node* bMap = new map_node;
      bufferMap.insert( std::pair<Key,
                     DTBufferTree<Key,Content>*>( *fKey, bMap ) );
      bMap->insert( ++fKey, lKey, cont );
      status = 0;
    }
    else {
      status = iter->second->insert( ++fKey, lKey, cont );
    }
  }
  return status;
}


template <class Key, class Content>
int DTBufferTree<Key,Content>::find( ElementKey fKey,
                                     ElementKey lKey,
                                     Content& cont ) {
  if ( fKey == lKey ) {
    cont = bufferContent;
    return 0;
  }
  else {
    map_iter iter = bufferMap.find( *fKey++ );
    if ( iter != bufferMap.end() ) {
      return iter->second->find( fKey, lKey, cont );
    }
    cont = defaultContent;
    return 1;
  }
}


