// #include "RecoTracker/TrackProducer/interface/TrackProducerAlgorithm.h"

#include "DataFormats/Common/interface/OrphanHandle.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"

#include "MagneticField/Engine/interface/MagneticField.h"
#include "Geometry/CommonDetUnit/interface/TrackingGeometry.h"

#include "DataFormats/TrajectorySeed/interface/TrajectorySeed.h"
#include "DataFormats/TrackCandidate/interface/TrackCandidate.h"
#include "DataFormats/TrackingRecHit/interface/TrackingRecHitFwd.h"

#include "TrackingTools/PatternTools/interface/TrajectoryFitter.h"
#include "TrackingTools/TrajectoryState/interface/TrajectoryStateOnSurface.h"
#include "TrackingTools/TrajectoryState/interface/TrajectoryStateTransform.h"
#include "TrackingTools/TransientTrackingRecHit/interface/TransientTrackingRecHitBuilder.h"
#include "RecoTracker/TransientTrackingRecHit/interface/TkTransientTrackingRecHitBuilder.h"
#include "TrackingTools/PatternTools/interface/TransverseImpactPointExtrapolator.h"
#include "TrackingTools/TransientTrack/interface/TransientTrack.h"
#include "RecoTracker/TrackProducer/interface/TrackingRecHitLessFromGlobalPosition.h"
//#include "RecoTracker/TrackProducer/interface/HitSplitter.h"

#include "TrackingTools/PatternTools/interface/TSCPBuilderNoMaterial.h"
#include "Utilities/General/interface/CMSexception.h"

#include "RecoTracker/TransientTrackingRecHit/interface/TRecHit2DPosConstraint.h"
#include "RecoTracker/TransientTrackingRecHit/interface/TRecHit1DMomConstraint.h"
#include "TrackingTools/MaterialEffects/interface/PropagatorWithMaterial.h"
#include "DataFormats/GeometryCommonDetAlgo/interface/ErrorFrameTransformer.h"
#include "TrackingTools/TrackFitters/interface/RecHitSorter.h"


using namespace std;

template <class T> void
TrackProducerAlgorithm<T>::runWithCandidate(const TrackingGeometry * theG,
					    const MagneticField * theMF,
					    const TrackCandidateCollection& theTCCollection,
					    const TrajectoryFitter * theFitter,
					    const Propagator * thePropagator,
					    const TransientTrackingRecHitBuilder* builder,
			   		    const reco::BeamSpot& bs,
					    AlgoProductCollection& algoResults)
{
  edm::LogInfo("TrackProducer") << "Number of TrackCandidates: " << theTCCollection.size() << "\n";

  int cont = 0;
  for (TrackCandidateCollection::const_iterator i=theTCCollection.begin(); i!=theTCCollection.end();i++)
    {
      
      const TrackCandidate * theTC = &(*i);

      PTrajectoryStateOnDet state = theTC->trajectoryStateOnDet();
      const TrackCandidate::range& recHitVec=theTC->recHits();
      const TrajectorySeed& seed = theTC->seed();

      //convert PTrajectoryStateOnDet to TrajectoryStateOnSurface
      TrajectoryStateTransform transformer;
  
      DetId  detId(state.detId());
      TrajectoryStateOnSurface theTSOS = transformer.transientState( state,
								     &(theG->idToDet(detId)->surface()), 
								     theMF);

      LogDebug("TrackProducer") << "Initial TSOS\n" << theTSOS << "\n";
      
      //convert the TrackingRecHit vector to a TransientTrackingRecHit vector
      TransientTrackingRecHit::RecHitContainer hits;
      
      float ndof=0;     
      for (edm::OwnVector<TrackingRecHit>::const_iterator i=recHitVec.first;
	   i!=recHitVec.second; i++){
	hits.push_back(builder->build(&(*i) ));
      }      
      
      //build Track
      LogDebug("TrackProducer") << "going to buildTrack"<< "\n";      
      bool ok = buildTrack(theFitter,thePropagator,algoResults, hits, theTSOS, seed, ndof, bs, theTC->seedRef());
      LogDebug("TrackProducer") << "buildTrack result: " << ok << "\n";
      if(ok) cont++;
    }
  edm::LogInfo("TrackProducer") << "Number of Tracks found: " << cont << "\n";
}

template <class T> void
TrackProducerAlgorithm<T>::runWithTrack(const TrackingGeometry * theG,
					const MagneticField * theMF,
					const TrackCollection& theTCollection,
					const TrajectoryFitter * theFitter,
					const Propagator * thePropagator,
					const TransientTrackingRecHitBuilder* builder,
			   		const reco::BeamSpot& bs,
					AlgoProductCollection& algoResults)
{
  edm::LogInfo("TrackProducer") << "Number of input Tracks: " << theTCollection.size() << "\n";
  
  int cont = 0;
  for (typename TrackCollection::const_iterator i=theTCollection.begin(); i!=theTCollection.end();i++)
    {
      try{
	const T * theT = &(*i);
	float ndof=0;
	PropagationDirection seedDir = theT->seedDirection();

	// WARNING: here we assume that the hits are correcly sorted according to seedDir
	TransientTrackingRecHit::RecHitContainer hits;       
	for (trackingRecHit_iterator i=theT->recHitsBegin(); i!=theT->recHitsEnd(); i++){
	  hits.push_back(builder->build(&**i ));
	}
	
	TrajectoryStateOnSurface theInitialStateForRefitting = getInitialState(theT,hits,theG,theMF);

	// the seed has dummy state and hits.What matters for the fitting is the seedDirection;
	if (seedDir==anyDirection){//if anyDirection the seed direction is not stored in the root file: keep same order
	  throw cms::Exception("TrackProducer") 
	    << "ERROR: trying to refit a track which doesn't have a properly filled 'seed direction' data member" << std::endl;
	}

	const TrajectorySeed seed = TrajectorySeed(PTrajectoryStateOnDet(),
						   TrajectorySeed::recHitContainer(), seedDir);
	// =========================
	//LogDebug("TrackProducer") << "seed.direction()=" << seed.direction();

	//=====  the hits are in the same order as they were in the track::extra.        
	bool ok = buildTrack(theFitter,thePropagator,algoResults, hits, theInitialStateForRefitting, seed, ndof, bs, theT->seedRef());
	if(ok) cont++;
      }catch ( CMSexception & e){
	edm::LogError("TrackProducer") << "Genexception1: " << e.explainSelf() <<"\n";      
        throw;
      }
    }
  edm::LogInfo("TrackProducer") << "Number of Tracks found: " << cont << "\n";
  
}

template <class T> void
TrackProducerAlgorithm<T>::runWithMomentum(const TrackingGeometry * theG,
					   const MagneticField * theMF,
					   const TrackMomConstraintAssociationCollection& theTCollectionWithConstraint,
					   const TrajectoryFitter * theFitter,
					   const Propagator * thePropagator,
					   const TransientTrackingRecHitBuilder* builder,
			   		   const reco::BeamSpot& bs,
					   AlgoProductCollection& algoResults){
  
  edm::LogInfo("TrackProducer") << "Number of input Tracks: " << theTCollectionWithConstraint.size() << "\n";
  
  int cont = 0;
  for (TrackMomConstraintAssociationCollection::const_iterator i=theTCollectionWithConstraint.begin(); i!=theTCollectionWithConstraint.end();i++) {
      try{
	const T * theT = i->key.get();

	LogDebug("TrackProducer") << "Running Refitter with Momentum Constraint. p=" << i->val->first << " err=" << i->val->second;

	float ndof=0;
	PropagationDirection seedDir = theT->seedDirection();

	// WARNING: here we assume that the hits are correcly sorted according to seedDir
	TransientTrackingRecHit::RecHitContainer hits;       
	for (trackingRecHit_iterator j=theT->recHitsBegin(); j!=theT->recHitsEnd();++j){
	  hits.push_back(builder->build(&**j ));
	}

	TrajectoryStateOnSurface theInitialStateForRefitting = getInitialState(theT,hits,theG,theMF);

	double mom = i->val->first;//10;
	double err = i->val->second;//0.01;
	TransientTrackingRecHit::RecHitPointer testhit = 
	  TRecHit1DMomConstraint::build(((int)(theInitialStateForRefitting.charge())),
					mom,err,
					&theInitialStateForRefitting.surface());
	
	//no insert in OwnVector...
	TransientTrackingRecHit::RecHitContainer tmpHits;	
	tmpHits.push_back(testhit);
	for (TransientTrackingRecHit::RecHitContainer::const_iterator i=hits.begin(); i!=hits.end(); i++){
	  tmpHits.push_back(*i);
	}
	hits.swap(tmpHits);
	
	// the seed has dummy state and hits.What matters for the fitting is the seedDirection;
	const TrajectorySeed seed = TrajectorySeed(PTrajectoryStateOnDet(),
						   TrajectorySeed::recHitContainer(), seedDir);
	// =========================
	//LogDebug("TrackProducer") << "seed.direction()=" << seed.direction();
	
	//=====  the hits are in the same order as they were in the track::extra.        
	bool ok = buildTrack(theFitter,thePropagator,algoResults, hits, theInitialStateForRefitting, seed, ndof, bs, theT->seedRef());
	if(ok) cont++;
      }catch ( CMSexception & e){
	edm::LogError("TrackProducer") << "Genexception1: " << e.explainSelf() <<"\n";      
        throw;
      }
    }
  edm::LogInfo("TrackProducer") << "Number of Tracks found: " << cont << "\n";
  
}

template <class T> void
TrackProducerAlgorithm<T>::runWithVertex(const TrackingGeometry * theG,
					 const MagneticField * theMF,
					 const TrackVtxConstraintAssociationCollection& theTCollectionWithConstraint,
					 const TrajectoryFitter * theFitter,
					 const Propagator * thePropagator,
					 const TransientTrackingRecHitBuilder* builder,
			   		 const reco::BeamSpot& bs,
					 AlgoProductCollection& algoResults){

  edm::LogInfo("TrackProducer") << "Number of input Tracks: " << theTCollectionWithConstraint.size() << "\n";
  
  int cont = 0;
  for (TrackVtxConstraintAssociationCollection::const_iterator i=theTCollectionWithConstraint.begin(); i!=theTCollectionWithConstraint.end();i++) {
      try{
	const T * theT = i->key.get();

	LogDebug("TrackProducer") << "Running Refitter with Vertex Constraint. pos=" << i->val->first << " err=" << i->val->second.matrix();

	float ndof=0;
	PropagationDirection seedDir = theT->seedDirection();

	// WARNING: here we assume that the hits are correcly sorted according to seedDir
	TransientTrackingRecHit::RecHitContainer hits;       
	for (trackingRecHit_iterator j=theT->recHitsBegin(); j!=theT->recHitsEnd(); ++j){
	  hits.push_back(builder->build(&**j ));
	}

	TrajectoryStateOnSurface theInitialStateForRefitting = getInitialState(theT,hits,theG,theMF);

	const LocalPoint testpoint(0,0,0);
	GlobalPoint pos = i->val->first;
	GlobalError err = i->val->second;

	Propagator* myPropagator = new PropagatorWithMaterial(anyDirection,0.105,theMF);
	TransverseImpactPointExtrapolator extrapolator(*myPropagator);
	TrajectoryStateOnSurface tsosAtVtx = extrapolator.extrapolate(theInitialStateForRefitting,pos);
	
	const Surface * surfAtVtx = &tsosAtVtx.surface();
	

	LocalError testerror = ErrorFrameTransformer().transform(err, *surfAtVtx);
	
	
	TransientTrackingRecHit::RecHitPointer testhit = TRecHit2DPosConstraint::build(testpoint,testerror,surfAtVtx);
	
	//push constraining hit and sort along seed direction
	hits.push_back(testhit);
	RecHitSorter sorter = RecHitSorter();
	hits = sorter.sortHits(hits,seedDir);   // warning: I doubt it works for cosmic or beam halo tracks

	//use the state on the surface of the first hit (could be the constraint or not)
	theInitialStateForRefitting = myPropagator->propagate(*theInitialStateForRefitting.freeState(), *(hits[0]->surface()) );	  
	delete myPropagator;

	// the seed has dummy state and hits.What matters for the fitting is the seedDirection;
	const TrajectorySeed seed = TrajectorySeed(PTrajectoryStateOnDet(),
						   TrajectorySeed::recHitContainer(), seedDir);
	// =========================
	//LogDebug("TrackProducer") << "seed.direction()=" << seed.direction();

	//=====  the hits are in the same order as they were in the track::extra.        
	bool ok = buildTrack(theFitter,thePropagator,algoResults, hits, theInitialStateForRefitting, seed, ndof, bs, theT->seedRef());
	if(ok) cont++;
      } catch ( CMSexception & e){
	edm::LogError("TrackProducer") << "Genexception1: " << e.explainSelf() <<"\n";      
        throw;
      }
    }
  edm::LogInfo("TrackProducer") << "Number of Tracks found: " << cont << "\n";

}

template <class T> TrajectoryStateOnSurface
TrackProducerAlgorithm<T>::getInitialState(const T * theT,
					   TransientTrackingRecHit::RecHitContainer& hits,
					   const TrackingGeometry * theG,
					   const MagneticField * theMF){

  TrajectoryStateOnSurface theInitialStateForRefitting;
  //the starting state is the state closest to the first hit along seedDirection.
  TrajectoryStateTransform transformer;
  //avoiding to use transientTrack, it should be faster;
  TrajectoryStateOnSurface innerStateFromTrack=transformer.innerStateOnSurface(*theT,*theG,theMF);
  TrajectoryStateOnSurface outerStateFromTrack=transformer.outerStateOnSurface(*theT,*theG,theMF);
  TrajectoryStateOnSurface initialStateFromTrack = 
    ( (innerStateFromTrack.globalPosition()-hits.front()->det()->position()).mag2() <
      (outerStateFromTrack.globalPosition()-hits.front()->det()->position()).mag2() ) ? 
    innerStateFromTrack: outerStateFromTrack;       
  
  // error is rescaled, but correlation are kept.
  initialStateFromTrack.rescaleError(100);
  theInitialStateForRefitting = TrajectoryStateOnSurface(initialStateFromTrack.localParameters(),
							 initialStateFromTrack.localError(), 		      
							 initialStateFromTrack.surface(),
							 theMF);  
  
  return theInitialStateForRefitting;
}

