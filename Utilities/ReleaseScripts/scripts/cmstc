#!/usr/bin/env python
"""CMS TagCollector command-line tool. Feedback and Help: mojedasa@cern.ch

Available commands:
   tags, diff, difflast, tagset, search, pendingappr, ibs, lastib, pkghist,
   comment, sign, signall, rejectsign, approve, bypass, rejectappr, remove,
   pendingpkgs, approvepkgs, cmsdisttags, cmsdistdiff

Common commands:
   tags         Prints all tags of up to 4 releases.
   diff         Same, but only tags that differ.
 ^ difflast     Same, but only print tags of the last release given.
                (useful for executing 'addpkg -f' later on).

   tagset       Prints the tags of one tagset, given its ID.
   tagsetinfo   Prints the information of one tagset, given its ID.
                Includes the tags as well.

 * search       Searches for releases, packages, tagsets, users and categories
                and prints anything that matches.
                Searching for users includes the full names and emails.
                Returns at most 10 results per type of result
                (e.g. 10 releases + 10 packages + ...).

 ^ tagsappr     Prints Pending Approval tags of one or more releases,
                one or more tagsets, or both (i.e. it joins all the tags).
                Prints an error if several tags appear for a single package
                if the '-m' flag is not specified.
                Suitable for piping to addpkg (note: at the moment,
                addpkg does not read from stdin, use "-f" instead).
                Optional parameter: '-m' ('--multiple').
                   Allows multiple tags for a single package.

Integration Build commands:
   ibs          Prints the list of latest IBs for active releases
                with creation timestamps, time ordered.
                Optional parameter: Filter.
   lastib       Prints the last IB given a filter.
                Note: Only IBs for active releases are returned.

Miscellaneous commands:
 ^ pkghist      Prints the recent history of a package, i.e.:
                   * Prints recent CVS tags.
                   * Prints the first line of the description of the tag
                     if it was published in TagCollector.
                   * Prints the releases where the tag is, if any.

Tagset commands:
   > Common commands:
 * comment      Comment one or more tagsets.
                Mandatory parameter: '-c' ('--comment').

   > Pending Signatures queue commands:
 * sign         Sign one or more tagsets, for L2s.
                Optional parameter: '-c' ('--comment').
 * signall      Sign all signatures of one or more tagsets,
                for top-level admins.
                Optional parameter: '-c' ('--comment').
 * rejectsign   Reject one or more tagsets from the Pending Signatures queue,
                for L2s, Release Managers or authors of the tagsets.
                Optional parameter: '-c' ('--comment').

   > Pending Approval queue commands:
 * approve      Approve one or more tagsets, for Release Managers.
                Optional parameter: '-c' ('--comment').
 * bypass       Same, but bypass (i.e. skip signatures), for Release Managers.
                Optional parameter: '-c' ('--comment').
 * rejectappr   Reject one or more tagsets from the Pending Approval queue,
                for Release Managers.
                Optional parameter: '-c' ('--comment').

   > History (i.e. stack of the release) commands:
 * remove       Remove one or more tagsets, for Release Managers.
                Optional parameter: '-c' ('--comment').

New Package Request commands:
   pendingpkgs  Prints the list of packages pending approval in TC.
                Optional parameter: '-v' ('--verbose').
 * approvepkgs  Approves packages in TC and **creates them in CVS**.

CMSDIST (i.e. externals) commands:
   cmsdisttags  Prints all CMSDIST's tags of up to 4 CVS tags.
   cmsdistdiff  Same, but only tags that differ.

--

Commands that require signing in are marked with *.

Experimental commands are marked with ^ (i.e. their output/name/arguments may
change in the future with high probability, feedback is welcomed).

If you want to create scripts based on the output of this script,
please consider using the cmstc.py Python API directly instead.

Examples:
   cmstc tags          CMSSW_4_1_X
   cmstc tags          CMSSW_4_1_2 CMSSW_4_1_X
   cmstc diff          CMSSW_4_1_2 CMSSW_4_1_X
   cmstc diff          CMSSW_4_1_X CMSSW_4_2_X CMSSW_4_3_X
   cmstc difflast      CMSSW_4_1_2 CMSSW_4_1_X

   cmstc tagset        12345
   cmstc tagsetinfo    98765

   cmstc search        4_4
   cmstc search        align
   cmstc search        2011-01-01
   cmstc search        miguel

   cmstc tagsappr      CMSSW_4_1_X
   cmstc tagsappr      12345 98765
   cmstc tagsappr      CMSSW_4_1_X 12345 98765

   cmstc ibs
   cmstc ibs           4_2
   cmstc lastib        4_2

   cmstc pkghist       DQM/BeamMonitor

   cmstc sign          12345 98765
   cmstc approve       -c "this is the comment" 12345 98765
   cmstc bypass        12345
   cmstc ...

   cmstc pendingpkgs
   cmstc pendingpkgs   -v
   cmstc approvepkgs   TESTSubSystem/TestPackage9 TESTSubSystem/TestPackage10

   cmstc cmsdisttags   CMSSW_4_1_0_pre1
   cmstc cmsdistdiff   CMSSW_4_1_0_pre1 CMSSW_4_1_0_pre2
"""

__author__ = "Miguel Ojeda"
__copyright__ = "Copyright 2010-2011, CERN CMS"
__credits__ = ["Miguel Ojeda"]
__license__ = "Unknown"
__maintainer__ = "Miguel Ojeda"
__email__ = "mojedasa@cern.ch"
__status__ = "Staging"

import cmstc
import sys
import optparse
import subprocess
import re
from optparse import OptionParser

def _system(args):
  print "Running:", ' '.join(args)
  subprocess.check_call(args)

def _popen(args):
  p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, close_fds=True)
  r = p.communicate()[0]
  if p.returncode != 0:
    raise subprocess.CalledProcessError(p.returncode, ' '.join(args))
  return r

def _createCVSPackage(package, admins, developers):
  admins = ','.join(admins)
  developers = ','.join(developers)
  return _system(['CreateCVSPackage.pl', '--package=' + package, '--admin=' + admins, '--developers=' + developers])

def _queryCVS(args):
  return _popen(['cvs', '-q'] + args)

def _queryCVSHeaders(args):
  return _queryCVS(['rlog', '-h'] + args)

def _queryCVSDiff(old_rev, new_rev, args):
  return _queryCVS(['rdiff', '-u', '-r' + old_rev, '-r' + new_rev] + args)

def queryCVSDiff(old_tag, new_tag, package):
  return _queryCVSDiff(old_tag, new_tag, [package])

def queryCVSCheckout(tag, args):
  return _queryCVS(['co', '-p', '-r', tag] + args)

def _getRequire(l):
  if len(l) != 2 or l[0] != 'Requires:':
    return None
  external = l[1]
  if 'toolfile' in external:
    external = external.rsplit('-', 1)
    if len(external) != 2 or external[1] != 'toolfile':
      return None
    return external[0]
  return external

def _getExternalSpecFilename(external):
  return 'COMP/CMSDIST/' + external + '.spec'

def getCMSDIST(tag = 'HEAD'):
  s = queryCVSCheckout(tag, ['COMP/CMSDIST/cmssw-tool-conf.spec']).splitlines()
  externals = set([])
  for l in s:
    l = l.split()
    external = _getRequire(l)
    if not external:
      continue
    externals.add(external)
  ret = {}
  new_externals = externals
  while True:
    if len(new_externals) == 0:
      break
    s = queryCVSCheckout(tag, [_getExternalSpecFilename(e) for e in new_externals]).splitlines()
    new_externals = set([])
    for l in s:
      l = l.split()
      if len(l) == 5 and l[0] == '###' and l[1] == 'RPM' and (l[2] == 'external' or l[2] == 'cms' or l[2] == 'lcg'):
        external = l[3]
        version = l[4]
        if external in ret:
          if version != ret[external]:
            raise "Collision"
          continue
        ret[external] = version
        continue
      external = _getRequire(l)
      if not external or external in ret or external in new_externals:
        continue
      new_externals.add(external)
  return ret

def getCMSDISTs(tags, diff):
  cmsdists = {}
  for tag in tags:
    cmsdists[tag] = getCMSDIST(tag)
  externals = set([])
  for cmsdist in cmsdists:
    externals = externals.union(set(cmsdists[cmsdist].keys()))
  ret = []
  for external in externals:
    x = [external]
    y = set([])
    same = False
    for tag in tags:
      if external in cmsdists[tag]:
        z = cmsdists[tag][external]
      else:
        z = None
      x.append(z)
      y.add(z)
    if diff and len(y) == 1:
      continue
    ret.append(tuple(x))
  return sorted(ret)

def getPackageCVSTags(package_name, limit = 10):
  s = _queryCVSHeaders([package_name + '/.admin/developers',]).split('\n')
  r = re.compile("^.*(V[-0-9]+):.*$")
  tags = set([])
  for l in s:
    if len(tags) >= limit:
      break
    m = r.match(l)
    if not m:
      continue
    tags.add(m.groups()[0])
  return sorted(tags, reverse=True)

_maxtaglen = len('V01-01-01-01  ')

def formatTag(tag, maxlen = _maxtaglen):
  return tag + ' ' * (maxlen - len(tag))

def printTags(tags, maxlen = _maxtaglen):
  for tag in tags:
    l = ""
    for t in tag[1:]:
      if not t:
        t = '-'
      l += formatTag(t, maxlen)
    print l + tag[0]

def printIBs(ibs):
  for ib in ibs:
    print ib[1], ib[0]

def printIBsLast(ibs):
  for ib in ibs:
    print ib[0]

def cmd_tags(releases):
  printTags(cmstc.TagCollector().getReleasesTags(releases))

def cmd_diff(releases):
  printTags(cmstc.TagCollector().getReleasesTags(releases, True))

def cmd_difflast(releases):
  a = cmstc.TagCollector().getReleasesTags(releases, True)
  printTags([(x[0], x[-1]) for x in a])

def number(tag):
  if not tag.startswith("V"):
    raise RuntimeErrror("Not a valid tag %s" % tag) 
  digits = tag[1:].split("-")
  if len(digits) < 3 or len(digits) > 4:
    raise RuntimeError("Not a valid tag %s" % tag)
  if [x for x in digits if not x.isdigit()]:
    raise RuntimeError("Not a valid tag %s" % tag)
  digits = [int(x) for x in digits]
  # Handle the case we have V01-00-00-00 which 
  # must be grater than V01-00-00
  if len(digits) == 4:
    digits[3] += 1
  if len(digits) == 3:
    digits.append(0)
  return 1000000*digits[0] + 10000*digits[1] + 100*digits[2] + digits[3]

def cmd_tagset(args):
  import commands
  parser = optparse.OptionParser(usage="cmstc tagset [-a] <tagset-id> [<tagset-id> ..]")
  parser.add_option("-a", dest="doAdd", action="store_true", default=False, help="Checkout tags")
  parser.add_option("--merge", "-m", dest="doMerge", action="store_true", default=False, help="Merge tagsets by picking most recent tags when there are overlaps")
  opts, tagsets = parser.parse_args(args)
  allTags = {}
  # If --merge is specified, we only update packages which have more recent tags.
  for tagset in tagsets:
    tags = cmstc.TagCollector().getTagsetTags(tagset)
    if not opts.doMerge:
      allTags.update(tags)
    else:
      for (name, version) in tags:
        if not name in allTags:
          allTags[name] = version
        elif number(version) > number(allTags[name]):
          allTags[name] = version
  allTags = allTags.items()
  printTags(allTags) 
  if not opts.doAdd:
    return
  for (name, version) in allTags:
    command = "addpkg %s %s" % (name, version)
    error, output = commands.getstatusoutput(command)
    print output
    if error:
      print output
      raise RuntimeError("Error while downloading package %s %s." % (name, version))

def cmd_tagsetinfo(tagset):
  if len(tagset) != 1:
    raise Exception("Error: Expected a tagset.")
  tagset = tagset[0]
  information = cmstc.TagCollector().getTagsetInformation(tagset)
  print '   Tagset: ', information['id']
  print '  Release: ', information['release_name']
  print '    State: ', information['state']
  print '   Author: ', information['author']
  print
  print 'Tagset:'
  printTags(cmstc.TagCollector().getTagsetTags(tagset))
  print
  print 'Description:'
  print information['description']

def cmd_search(term):
  if len(term) != 1:
    raise Exception("Error: Expected a single word.")
  term = term[0]
  tc = cmstc.TagCollector()
  tc.signInInteractive()
  results = tc.search(term)
  for result in results:
    print ' '*(10 - len(result['type'])) + result['type'] + '  ' + result['value']

def cmd_tagsappr(args):
  parser = optparse.OptionParser()
  parser.add_option("-m", "--multiple", action="store_true", dest="multiple", default=False)
  (opts, args) = parser.parse_args(args)
  multiple = opts.multiple
  if len(args) < 1:
    raise Exception("Error: Expected at least a tagset ID or release name.")
  printTags(sorted(cmstc.TagCollector().getPendingApprovalTags(args, multiple)))

def cmd_ibs(filt):
  if filt:
    filt = filt[0]
  else:
    filt = ''
  printIBs(cmstc.TagCollector().getIBs(filt))

def cmd_lastib(filt):
  if len(filt) != 1:
    raise Exception("Error: Expected a filter (single word).")
  filt = filt[0]
  printIBsLast(cmstc.TagCollector().getIBs(filt, 1))

def cmd_pkghist(package):
  if len(package) != 1:
    raise Exception("Error: Expected a package (single word).")
  package = package[0]
  tc = cmstc.TagCollector()
  tags = tc.getPackageTags(package)
  cvstags = getPackageCVSTags(package)
  for cvstag in cvstags:
    tagdescription = ''
    tagreleases = ()
    if cvstag in tags:
      tagdescription = tc.getPackageTagDescriptionFirstLine(package, cvstag)
      tagreleases = tc.getPackageTagReleases(package, cvstag)
    print formatTag(cvstag) + tagdescription
    for tagrelease in tagreleases:
      print ' ' * _maxtaglen + tagrelease

def tagset_cmd(args, command):
  parser = optparse.OptionParser()
  parser.add_option("-c", "--comment", dest="comment", default='')
  (opts, args) = parser.parse_args(args)
  tagset_ids = args
  comment = opts.comment
  if len(tagset_ids) < 1:
    raise Exception("Error: Expected at least one tagset ID.")
  print 'Tagset IDs:', tagset_ids
  print '   Comment: "' + comment + '"'
  tc = cmstc.TagCollector()
  tc.signInInteractive()
  getattr(tc, command)(tagset_ids, comment)

def cmd_comment(args):
  tagset_cmd(args, 'commentTagsets')

def cmd_sign(args):
  tagset_cmd(args, 'signTagsets')

def cmd_signall(args):
  tagset_cmd(args, 'signTagsetsAll')

def cmd_rejectsign(args):
  tagset_cmd(args, 'rejectTagsetsPendingSignatures')

def cmd_approve(args):
  tagset_cmd(args, 'approveTagsets')

def cmd_bypass(args):
  tagset_cmd(args, 'bypassTagsets')

def cmd_rejectappr(args):
  tagset_cmd(args, 'rejectTagsetsPendingApproval')

def cmd_remove(args):
  tagset_cmd(args, 'removeTagsets')

def cmd_pendingpkgs(args):
  parser = optparse.OptionParser()
  parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False)
  (opts, args) = parser.parse_args(args)
  packages = cmstc.TagCollector().getPackagesPendingApproval()
  if not opts.verbose:
    packages = sorted([p[0] for p in packages])
    for package in packages:
      print package
    return
  for package in packages:
    print "    Package:", package[0]
    print "Description:", package[1].splitlines()[0][:60], '(...)'
    print "  Requested:", package[2]
    print

def cmd_approvepkgs(packages):
  if len(packages) < 1:
    return
  tc = cmstc.TagCollector()
  tc.signInInteractive()
  pending_packages = tc.getPackagesPendingApproval()
  pending_packages = frozenset([p[0] for p in pending_packages])
  for package in packages:
    print "Package", package
    if package not in pending_packages:
      raise Exception("Error: The package is not pending approval.")
    print "Getting list of admins and developers from TC..."
    (developers, admins) = tc.getPackageManagersRequested(package)
    if len(developers) < 1:
      raise Exception("Error: No developers?!")
    if len(admins) < 1:
      raise Exception("Error: No admins?!")
    print "      Admins =", ','.join(admins)
    print "  Developers =", ','.join(developers)
    print "Getting list of admins and developers from TC... DONE"
    print "Creating package in CVS..."
    _createCVSPackage(package, admins, developers)
    print "Creating package in CVS... DONE"
    print "Approving package in TC..."
    tc.approvePackage(package)
    print "Approving package in TC... DONE"
  tc.signOut()

def cmd_cmsdisttags(cvstags):
  printTags(getCMSDISTs(cvstags, False), 20)

def cmd_cmsdistdiff(cvstags):
  printTags(getCMSDISTs(cvstags, True), 20)

def main():
  try:
    args = sys.argv[1:]
    cmd = globals()['cmd_' + args[0]]
  except:
    print __doc__
    sys.exit(-1)

  try:
    cmd(args[1:])
  except Exception as e:
    print "Exception:", e
    sys.exit(-1)

if __name__ == "__main__":
  main()

