#!/usr/bin/env perl
use Cwd;
use File::Basename;
use lib dirname($0);
use Getopt::Long;
use SCRAMGenUtils;
$|=1;

my $curdir=cwd();
my $scriptdir=dirname($0);
my $package=shift || die "Usage: $0 <Subsystem/Package|clean>";
my $xincargs="";
while(my $arg=shift)
{
  if($arg=~/\s/){$arg="\"$arg\"";}
  $xincargs.=" $arg";
}

my $localtop = &SCRAMGenUtils::scramReleaseTop($curdir);
if($localtop eq ""){die "\"$curdir\" is not a SCRAM-based project area. Please create a SCRAM-based project dev area and run this script";}
if(&SCRAMGenUtils::getFromEnvironmentFile("RELEASETOP",$localtop) eq "")
{die "\"$localtop\" is a release area. Please run this script in your developer area.\n";}
my $releasetop=&SCRAMGenUtils::getFromEnvironmentFile("RELEASETOP","$localtop") || $localtop;
if($releasetop eq $localtop){die "Release top should not equal to localtop \"$localtop\"\n";}

my $arch=&SCRAMGenUtils::getScramArch();
my $tmpdir="${localtop}/tmp/${arch}/includechecker";

$package=~s/^\s*//;$package=~s/\s*$//;
if($package=~/^clean$/i){system("rm -rf $tmpdir");print "Tmp area \"$tmpdir\" cleaned up.\n";exit 0;}

my $src=&SCRAMGenUtils::getFromEnvironmentFile("SCRAM_SOURCEDIR",$localtop) || "src";
if (!-d $package){$package="${src}/${package}";}
if(-d $package)
{
  my $d=$package;
  if($d!~/^\//){$d="${curdir}/${package}";}
  $d=&SCRAMGenUtils::fixPath($d);
  if($d=~/^$localtop\/(${src}\/*.*)$/){$package=$1;}
}
if($package eq ""){die "Please use a valid Subsystem/Package name.\n  Usage: $0 <Subsystem/Package|clean>";}
if(!-d "${localtop}/${package}")
{die "There is no such subsystem/package/directory \"$package\" available under \"${localtop}\". Please first checkout this package.";}
my $scram=$SCRAMGenUtils::SCRAM_CMD;
system("mkdir -p ${tmpdir}/config ${tmpdir}/log;$scram b -r echo_CXX >/dev/null 2>&1");
my $incmap=&copyExternalIncludes ($arch,$localtop,"${tmpdir}/inccopy");

print ">> IncludeChecker temporary directory: ${tmpdir}\n";

my $cache={};
my $cfile="${tmpdir}/cache/files.info";
if(-f $cfile){$cache=&SCRAMGenUtils::readHashCache($cfile);}
&processPack ($package,$cache);
if(-d "${tmpdir}/cache"){&SCRAMGenUtils::writeHashCache($cache,$cfile);}
system("rm -f ${tmp_dir}/chkquit");
exit 0;

sub processPack ()
{
  if (-f "${tmp_dir}/chkquit"){return;}
  my $package=shift;
  my $cache=shift;
  my $uniqpack=$package; $uniqpack=~s/\///g;
  my $configfile="${tmpdir}/config/${uniqpack}";
  print "################# $package #############################\n";
  print ">> IncludeChecker log file           : ${tmpdir}/log/${uniqpack}\n";
  print ">> IncludeChecker config file        : ${tmpdir}/config/${uniqpack}\n";
  my $cont=0;
  if(-f "${tmpdir}/log/${uniqpack}")
  {
    my $c=0;
    while(-f "${tmpdir}/log/${uniqpack}.${c}"){$c++;}
    system("mv ${tmpdir}/log/${uniqpack} ${tmpdir}/log/${uniqpack}.${c}");
    $cont=1;
  }
  if((-f "${tmpdir}/cache/config_cache") && ($cont==0)){system("touch ${tmpdir}/cache/config_cache.append");}
  else{system("rm -f ${tmpdir}/cache/config_cache.append");}
  if(!-f $configfile)
  {
    print ">> Running \"${scriptdir}/createconfig.pl ${localtop}/${package}\"\n";
    system("${scriptdir}/createconfig.pl ${localtop}/${package} > ${configfile}.tmp && mv ${configfile}.tmp $configfile");
    if(-f "extra_includechecker.conf"){system("cat extra_includechecker.conf >> $configfile");}
    &updateMapping($configfile,$incmap);
  }
  print ">> Running \"includechecker.pl --config $configfile --tmpdir $tmpdir --keep --detail --recursive --local --skipheaders $xincargs\"\n";
  system("${scriptdir}/includechecker.pl --config $configfile --tmpdir $tmpdir --keep --detail --recursive --local --skipheaders $xincargs 2>&1 > ${tmpdir}/log/${uniqpack}");
  if(-f "${tmp_dir}/chkquit"){return;}
  &processResult($cache);
  my $deps=&copyNewFiles();
  foreach my $pack (keys %$deps)
  {
    my $packx=$pack; $packx=~s/\///;
    if(!-f "${tmpdir}/config/${packx}"){&processPack("${src}/${pack}",$cache);}
  }
}

sub processResult ()
{
  my $cache=shift;
  my $newfiles = &getNewFiles("${tmpdir}/cache/files");
  my $done=[];
  my $failed=[];
  my $skipped=[];
  my $total=0;
  foreach my $f (@$newfiles)
  {
    if(-f $f)
    {
      my $rf=$f; $rf=~s/^${tmpdir}\/cache\/files\///;
      if(exists $cache->{read}{$rf}){next;}
      $cache->{read}{$rf}=1;
      $total++;
      foreach my $line (`cat $f`)
      {
        chomp $line;
        if($line=~/^\s*(ERROR|INTERNAL_SKIP|FINAL_DONE)\=\>\((\d+)\)\s*$/)
        {
	  my $type=$1; my $val=$2;
	  if($val == 1)
	  {
	    if($type eq "ERROR"){push @$failed,$rf;}
	    elsif($type eq "FINAL_DONE"){push @$done,$rf;}
	    else{push @$skipped,$rf;}
	  }
        }
      }
    }
  }
  print "Total files checked:           $total\n";
  print "  Failed due to compilation:   ",scalar(@$failed),"\n";
  foreach my $f (@$failed){print "    $f\n";}
  print "  Skipped:                     ",scalar(@$skipped),"\n";
  foreach my $f (@$skipped){print "    $f\n";}
  print "  Successfully processed:      ",scalar(@$done),"\n";
}

sub copyNewFiles ()
{
  my $newdeps={};
  my $newfiles = &getNewFiles("${tmpdir}/includechecker");
  my $modfile=scalar(@$newfiles);
  my $doscramb=0;
  foreach my $f (@$newfiles)
  {
    my $rf=$f; $rf=~s/^${tmpdir}\/includechecker\/${src}\///;
    my $pack=$rf; $pack=~s/^([^\/]+?\/[^\/]+?)\/.+/$1/;
    if(!-d "${localtop}/${src}/${pack}")
    {
      if(-d "${releasetop}/${src}/${pack}")
      {
        my $subsys=dirname("${localtop}/${src}/${pack}");
        system("mkdir -p $subsys; cp -r ${releasetop}/${src}/${pack} $subsys");
        $doscramb=1;
	$newdeps->{$pack}=1;
      }
    }
    my $oref; my $iref;
    my $added=0; my $removed=0;
    open($iref,$f) || die "Can not open file \"$f\" for reading.";
    open($oref,">$f.backup_new") || die "Can not open file \"$f.backup_new\" for writing.";
    while(my $line=<$iref>)
    {
      chomp $line;
      if($line=~/^\s*\/\/INCLUDECHECKER: Removed this line:/){$removed++;next;}
      elsif($line=~/(.*?)\/\/INCLUDECHECKER: Added this line\s*$/){$added++;$line=$1;}
      print $oref "$line\n";
    }
    close($oref); close($iref);
    if ($removed || $added)
    {
      system("cp $f.backup_new ${localtop}/${src}/${rf}; mv $f $f.modified_by_incchk");
      print "    $rf ($removed,$added)\n";
    }
    else{system("rm -f $f.backup_new $f");$modfile--;}
  }
  if($modfile == 0){print "It seemed that file(s) processed successfully by includechecker are all good. No include statement added/removed.\n";}
  else{print "  Modified by includechecker:  $modfile\n";}
  if($doscramb){system("cd $localtop; $scram b -r echo_CXX 2>&1 > /dev/null");}
  return $newdeps;
}

sub getNewFiles ()
{
  my $dir=shift;
  my $files=shift || [];
  foreach my $d (&SCRAMGenUtils::readDir($dir))
  {
    my $fullpath="${dir}/${d}";
    if(-d $fullpath){&getNewFiles($fullpath,$files);}
    elsif(-f $fullpath)
    {
      if($fullpath=~/(.*?)\.(backup_new|modified_by_incchk)$/){next;}
      push @$files,$fullpath;
    }
  }
  return $files;
}

sub copyExternalIncludes ()
{
  my $arch=shift;
  my $release=shift;
  my $des=shift;
  my $map=shift || {};

  my %incdir=();
  my %cache=();
  $cache{toolcache}=&SCRAMGenUtils::readCache("${release}/.SCRAM/${arch}/ToolCache.db");

  if(exists $cache{toolcache}{SETUP})
  {
    foreach my $t (keys %{$cache{toolcache}{SETUP}})
    {
      if(exists $cache{toolcache}{SETUP}{$t}{INCLUDE})
      {
        my $c=0;
        foreach my $d (@{$cache{toolcache}{SETUP}{$t}{INCLUDE}})
        {
	  if(-d $d)
	  {
	    my $inc="inc$c";
	    $incdir{$d}{$t}="$inc";
	    $c++;
	    if (($t eq "self") && ($d eq "${release}/${src}") && (!-e "${des}/${t}/${inc}"))
	    {system("mkdir -p ${des}/${t}; cd ${des}/${t}; ln -s ${release}/${src} ${inc}");}
	  }
	}
      }
    }
  }

  my %udir=();
  foreach my $d (sort keys %incdir)
  {
    my $link="";
    foreach my $ud (keys %udir)
    {
      my $xud=quotemeta($ud);
      if ($d=~/^$xud(\/.*|)$/)
      {
        $link=$udir{$ud};
        last;
      }
    }
    foreach my $t (keys %{$incdir{$d}})
    {
      my $inc=$incdir{$d}{$t};
      my $xd=quotemeta($d);
      $map->{$xd}="${des}/${t}/${inc}";
      if(!-e "${des}/${t}/${inc}")
      {
        system("mkdir -p ${des}/${t}");
        if(!$link){system("cp -rL $d ${des}/${t}/${inc}");$link="../${t}/${inc}";}
        else{system("cd ${des}/${t}; ln -s ${link} $inc");}
      }
      elsif($link eq ""){$link="../${t}/${inc}";}
    }
    $udir{$d}=$link;
  }
  &SCRAMGenUtils::writeHashCache($map,"${des}/mapping.txt");
  return $map;
}

sub updateMapping ()
{
  my $file=shift;
  my $map=shift;
  my $refi;my $refo;
  open($refi,$file) || die "Can not open file for reading: $file\n";
  open($refo,">${file}.new") || die "Can not open file for writing: ${file}.new\n";
  while(my $line=<$refi>)
  {
    chomp $line;
    foreach my $xd (keys %{$map})
    {
      while($line=~/^(.*)$xd(\/.*|\s.*|)$/)
      {
        my $d=$map->{$xd};
	$line="$1$d$2";
      }
    }
    print $refo "$line\n";
  }
  close($refi); close($refo);
  system("mv ${file}.new $file");
}
